extern use "rayjule/main.cpp"
extern use "rayjule/main.hpp"

use "std/math"
use "std/jule"

const PI:f32=3.14159265358979323846
const EPSILON:f32=0.000001
const DEG2RAD:f32= PI/180
const RAD2DEG:f32= 180/PI

let LIGHTGRAY: Color  = Color{200, 200, 200, 255}  // Light Gray
let GRAY: Color       = Color{130, 130, 130, 255}  // Gray
let DARKGRAY: Color   = Color{80, 80, 80, 255}     // Dark Gray
let YELLOW: Color     = Color{253, 249, 0, 255}    // Yellow
let GOLD: Color       = Color{255, 203, 0, 255}    // Gold
let ORANGE: Color     = Color{255, 161, 0, 255}    // Orange
let PINK: Color       = Color{255, 109, 194, 255}  // Pink
let RED: Color        = Color{230, 41, 55, 255}    // Red
let MAROON: Color     = Color{190, 33, 55, 255}    // Maroon
let GREEN: Color      = Color{0, 228, 48, 255}     // Green
let LIME: Color       = Color{0, 158, 47, 255}     // Lime
let DARKGREEN: Color  = Color{0, 117, 44, 255}     // Dark Green
let SKYBLUE: Color    = Color{102, 191, 255, 255}  // Sky Blue
let BLUE: Color       = Color{0, 121, 241, 255}    // Blue
let DARKBLUE: Color   = Color{0, 82, 172, 255}     // Dark Blue
let PURPLE: Color     = Color{200, 122, 255, 255}  // Purple
let VIOLET: Color     = Color{135, 60, 190, 255}   // Violet
let DARKPURPLE: Color = Color{112, 31, 126, 255}   // Dark Purple
let BEIGE: Color      = Color{211, 176, 131, 255}  // Beige
let BROWN: Color      = Color{127, 106, 79, 255}   // Brown
let DARKBROWN: Color  = Color{76, 63, 47, 255}     // Dark Brown
let WHITE: Color      = Color{255, 255, 255, 255}  // White
let BLACK: Color      = Color{0, 0, 0, 255}        // Black
let BLANK: Color      = Color{0, 0, 0, 0}          // Blank (Transparent)
let MAGENTA: Color    = Color{255, 0, 255, 255}    // Magenta
let RAYWHITE: Color   = Color{245, 245, 245, 255}  // My own White (raylib logo)

extern type char: byte
type Char = extern.char

#typedef
extern struct Vector2 {
	x: f32
	y: f32
}

type Vector2 = extern.Vector2

#typedef
extern struct Vector3 {
	x: f32
	y: f32
	z: f32
}

type Vector3 = extern.Vector3

#typedef
extern struct Vector4 {
	x: f32
	y: f32
	z: f32
	w: f32
}

type Vector4 = extern.Vector4
type Quaternion = Vector4

#typedef
extern struct Matrix {
	m0:  f32
	m4:  f32
	m8:  f32
	m12: f32

	//
	m1:  f32
	m5:  f32
	m9:  f32
	m13: f32

	m2:  f32
	m6:  f32
	m10: f32
	m14: f32

	m3:  f32
	m7:  f32
	m11: f32
	m15: f32
}

type Matrix = extern.Matrix

#typedef
extern struct Color {
	r: u8
	b: u8
	g: u8
	a: u8
}

type Color = extern.Color

#typedef
extern struct Rectangle {
	x:      f32
	y:      f32
	width:  f32
	height: f32
}

type Rectangle = extern.Rectangle

#typedef
extern struct Image {
	data:    *extern.char
	width:   int
	height:  int
	mipmaps: int
	format:  int
}

type Image = extern.Image

#typedef
extern struct Texture {
	id:      u32
	width:   int
	height:  int
	mipmaps: int
	format:  int
}

type Texture = extern.Texture
type Texture2D = Texture
type TextureCubemap = Texture

#typedef
extern struct RenderTexture {
	id:      u32     // OpenGL framebuffer object id
	texture: Texture // Color buffer attachment texture
	depth:   Texture // Depth buffer attachment texture
}

type RenderTexture = extern.RenderTexture
type RenderTexture2D = RenderTexture

#typedef
extern struct NPatchInfo {
	source: Rectangle
	left:   i32
	top:    i32
	right:  i32
	bottom: i32
	layout: i32
}

type NPatchInfo = extern.NPatchInfo

#typedef
extern struct GlyphInfo {
	value:    i32   // Character value (Unicode)
	offsetX:  i32   // Character offset X when drawing
	offsetY:  i32   // Character offset Y when drawing
	advanceX: i32   // Character advance position X
	image:    Image // Character image data
}

type GlyphInfo = extern.GlyphInfo

#typedef
extern struct Font {
	baseSize:     i32         // Base size (default chars height)
	glyphCount:   i32         // Number of glyph characters
	glyphPadding: i32         // Padding around the glyph characters
	texture:      Texture2D   // Texture atlas containing the glyphs
	recs:         []Rectangle // Rectangles in texture for the glyphs
	glyphs:       []GlyphInfo // Glyphs info data
}

type Font = extern.Font

#typedef
extern struct Camera3D {
	position:   Vector3 // Camera position
	target:     Vector3 // Camera target it looks-at
	up:         Vector3 // Camera up vector (rotation over its axis)
	fovy:       f32     // Camera field-of-view aperture in Y (degrees) in perspective, used as near plane width in orthographic
	projection: int     // Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
}

type Camera3D = extern.Camera3D
type Camera = Camera3D

#typedef
extern struct Camera2D {
	offset:   Vector2 // Camera offset (displacement from target)
	target:   Vector2 // Camera target (rotation and zoom origin)
	rotation: f32     // Camera rotation in degrees
	zoom:     f32     // Camera zoom (scaling), should be 1.0f by default
}

type Camera2D = extern.Camera2D

#typedef
extern struct Mesh {
	vertexCount:   i32 // Number of vertices stored in arrays
	triangleCount: i32 // Number of triangles stored (indexed or not)

	// Vertex attributes data
	vertices:   []f32 // Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
	texcoords:  []f32 // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
	texcoords2: []f32 // Vertex texture second coordinates (UV - 2 components per vertex) (shader-location = 5)
	normals:    []f32 // Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
	tangents:   []f32 // Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
	colors:     []u8  // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
	indices:    []u8  // Vertex indices (in case vertex data comes indexed)

	// Animation vertex data
	animVertices: []f32    // Animated vertex positions (after bones transformations)
	animNormals:  []f32    // Animated normals (after bones transformations)
	boneIds:      []u8     // Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning) (shader-location = 6)
	boneWeights:  []f32    // Vertex bone weight, up to 4 bones influence by vertex (skinning) (shader-location = 7)
	boneMatrices: []Matrix // Bones animated transformation matrices
	boneCount:    i32      // Number of bones

	// OpenGL identifiers
	vaoId: u32   // OpenGL Vertex Array Object id
	vboId: []u32 // OpenGL Vertex Buffer Objects id (default vertex data)
}

type Mesh = extern.Mesh

#typedef
extern struct Shader {
	id:   u32
	locs: []i32
}

type Shader = extern.Shader

// MaterialMap
#typedef
extern struct MaterialMap {
	texture: Texture2D // Material map texture
	color:   Color     // Material map color
	value:   f32       // Material map value
}

type MaterialMap = extern.MaterialMap

#typedef
extern struct Material {
	shader: Shader       // Material shader
	maps:   *MaterialMap // Material maps array (MAX_MATERIAL_MAPS)
	params: [4]f32       // Material generic parameters (if required)
}

type Material = extern.Material

#typedef
extern struct Transform {
	translation: Vector3    // Translation
	rotation:    Quaternion // Rotation
	scale:       Vector3    // Scale
}

type Transform = extern.Transform

// Bone, skeletal animation bone
#typedef
extern struct BoneInfo {
	name:   [32]extern.char // Bone name
	parent: i32          // Bone parent
}

type BoneInfo = extern.BoneInfo

// Model, meshes, materials and animation data
#typedef
extern struct Model {
	transform: Matrix // Local transform matrix

	meshCount:     i32       // Number of meshes
	materialCount: i32       // Number of materials
	meshes:        *Mesh     // Meshes array
	materials:     *Material // Materials array
	meshMaterial:  *i32      // Mesh material number

	// Animation data
	boneCount: i32        // Number of bones
	bones:     *BoneInfo  // Bones information (skeleton)
	bindPose:  *Transform // Bones base transformation (pose)
}

type Model = extern.Model

// ModelAnimation
#typedef
extern struct ModelAnimation {
	boneCount:  i32          // Number of bones
	frameCount: i32          // Number of animation frames
	bones:      *BoneInfo    // Bones information (skeleton)
	framePoses: **Transform  // Poses array by frame
	name:       [32]extern.char // Animation name
}

type ModelAnimation = extern.ModelAnimation

// Ray, ray for raycasting
#typedef
extern struct Ray {
	position:  Vector3 // Ray position (origin)
	direction: Vector3 // Ray direction (normalized)
}

type Ray = extern.Ray

// RayCollision, ray hit information
#typedef
extern struct RayCollision {
	hit:      bool    // Did the ray hit something?
	distance: f32     // Distance to the nearest hit
	point:    Vector3 // Point of the nearest hit
	normal:   Vector3 // Surface normal of hit
}

type RayCollision = extern.RayCollision

// BoundingBox
#typedef
extern struct BoundingBox {
	min: Vector3 // Minimum vertex box-corner
	max: Vector3 // Maximum vertex box-corner
}

type BoundingBox = extern.BoundingBox

// Wave, audio wave data
#typedef
extern struct Wave {
	frameCount: u32  // Total number of frames (considering channels)
	sampleRate: u32  // Frequency (samples per second)
	sampleSize: u32  // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
	channels:   u32  // Number of channels (1-mono, 2-stereo, ...)
	data:       *any // Buffer data pointer
}

type Wave = extern.Wave

//// Opaque structs declaration
//// NOTE: Actual structs are defined internally in raudio module
//typedef struct rAudioBuffer rAudioBuffer;
//typedef struct rAudioProcessor rAudioProcessor;
//
//// AudioStream, custom audio stream
//typedef struct AudioStream {
//    rAudioBuffer *buffer;       // Pointer to internal data used by the audio system
//    rAudioProcessor *processor; // Pointer to internal data processor, useful for audio effects
//
//    unsigned int sampleRate;    // Frequency (samples per second)
//    unsigned int sampleSize;    // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
//    unsigned int channels;      // Number of channels (1-mono, 2-stereo, ...)
//} AudioStream;
//
//// Sound
//typedef struct Sound {
//    AudioStream stream;         // Audio stream
//    unsigned int frameCount;    // Total number of frames (considering channels)
//} Sound;
//
//// Music, audio stream, anything longer than ~10 seconds should be streamed
//typedef struct Music {
//    AudioStream stream;         // Audio stream
//    unsigned int frameCount;    // Total number of frames (considering channels)
//    bool looping;               // Music looping enable
//
//    int ctxType;                // Type of music context (audio filetype)
//    void *ctxData;              // Audio context data, depends on type
//} Music;

#typedef
extern struct VrStereoConfig {
	projection:        [2]Matrix // VR projection matrices (per eye)
	viewOffset:        [2]Matrix // VR view offset matrices (per eye)
	leftLensCenter:    [2]f32    // VR left lens center
	rightLensCenter:   [2]f32    // VR right lens center
	leftScreenCenter:  [2]f32    // VR left screen center
	rightScreenCenter: [2]f32    // VR right screen center
	scale:             [2]f32    // VR distortion scale
	scaleIn:           [2]f32    // VR distortion scale in
}

type VrStereoConfig = extern.VrStereoConfig

// VrDeviceInfo, Head-Mounted-Display device parameters
#typedef
extern struct VrDeviceInfo {
	hResolution:            i32    // Horizontal resolution in pixels
	vResolution:            i32    // Vertical resolution in pixels
	hScreenSize:            f32    // Horizontal size in meters
	vScreenSize:            f32    // Vertical size in meters
	eyeToScreenDistance:    f32    // Distance between eye and display in meters
	lensSeparationDistance: f32    // Lens separation distance in meters
	interpupillaryDistance: f32    // IPD (distance between pupils) in meters
	lensDistortionValues:   [4]f32 // Lens distortion constant parameters
	chromaAbCorrection:     [4]f32 // Chromatic aberration correction parameters
}

type VrDeviceInfo = extern.VrDeviceInfo

// File path list
#typedef
extern struct FilePathList {
	capacity: u32        // Filepaths max entries
	count:    u32        // Filepaths entries count
	paths:    **extern.char // Filepaths entries
}

type FilePathList = extern.FilePathList

// Automation event
#typedef
extern struct AutomationEvent {
	frame: u32 // Event frame

	//TODO: origin name of this field is type
	_type:  u32    // Event type AutomationEventType
	params: [4]i32 // Event parameters if required
}

type AutomationEvent = extern.AutomationEvent

// Automation event list
#typedef
extern struct AutomationEventList {
	capacity: u32              // Events max entries MAX_AUTOMATION_EVENTS
	count:    u32              // Events entries count
	events:   *AutomationEvent // Events entries
}

type AutomationEventList = extern.AutomationEventList

enum ConfigFlags: u32 {
	FLAG_VSYNC_HINT: 0x00000040,               // Set to try enabling V-Sync on GPU
	FLAG_FULLSCREEN_MODE: 0x00000002,          // Set to run program in fullscreen
	FLAG_WINDOW_RESIZABLE: 0x00000004,         // Set to allow resizable window
	FLAG_WINDOW_UNDECORATED: 0x00000008,       // Set to disable window decoration (frame and buttons)
	FLAG_WINDOW_HIDDEN: 0x00000080,            // Set to hide window
	FLAG_WINDOW_MINIMIZED: 0x00000200,         // Set to minimize window (iconify)
	FLAG_WINDOW_MAXIMIZED: 0x00000400,         // Set to maximize window (expanded to monitor)
	FLAG_WINDOW_UNFOCUSED: 0x00000800,         // Set to window non focused
	FLAG_WINDOW_TOPMOST: 0x00001000,           // Set to window always on top
	FLAG_WINDOW_ALWAYS_RUN: 0x00000100,        // Set to allow windows running while minimized
	FLAG_WINDOW_TRANSPARENT: 0x00000010,       // Set to allow transparent framebuffer
	FLAG_WINDOW_HIGHDPI: 0x00002000,           // Set to support HighDPI
	FLAG_WINDOW_MOUSE_PASSTHROUGH: 0x00004000, // Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
	FLAG_BORDERLESS_WINDOWED_MODE: 0x00008000, // Set to run program in borderless windowed mode
	FLAG_MSAA_4X_HINT: 0x00000020,             // Set to try enabling MSAA 4X
	FLAG_INTERLACED_HINT: 0x00010000,          // Set to try enabling interlaced video format (for V3D)
}

enum TraceLogLevel: u32 {
	LOG_ALL: 0,  // Display all logs
	LOG_TRACE,   // Trace logging, intended for internal use only
	LOG_DEBUG,   // Debug logging, used for internal debugging, it should be disabled on release builds
	LOG_INFO,    // Info logging, used for program execution info
	LOG_WARNING, // Warning logging, used on recoverable failures
	LOG_ERROR,   // Error logging, used on unrecoverable failures
	LOG_FATAL,   // Fatal logging, used to abort program: exit(EXIT_FAILURE)
	LOG_NONE,    // Disable logging
}

enum KeyboardKey: int {
	KEY_NULL: 0, // Key: NULL, used for no key pressed

	// Alphanumeric keys
	KEY_APOSTROPHE: 39,    // Key: '
	KEY_COMMA: 44,         // Key: ,
	KEY_MINUS: 45,         // Key: -
	KEY_PERIOD: 46,        // Key: .
	KEY_SLASH: 47,         // Key: /
	KEY_ZERO: 48,          // Key: 0
	KEY_ONE: 49,           // Key: 1
	KEY_TWO: 50,           // Key: 2
	KEY_THREE: 51,         // Key: 3
	KEY_FOUR: 52,          // Key: 4
	KEY_FIVE: 53,          // Key: 5
	KEY_SIX: 54,           // Key: 6
	KEY_SEVEN: 55,         // Key: 7
	KEY_EIGHT: 56,         // Key: 8
	KEY_NINE: 57,          // Key: 9
	KEY_SEMICOLON: 59,     // Key: ;
	KEY_EQUAL: 61,         // Key: :
	KEY_A: 65,             // Key: A | a
	KEY_B: 66,             // Key: B | b
	KEY_C: 67,             // Key: C | c
	KEY_D: 68,             // Key: D | d
	KEY_E: 69,             // Key: E | e
	KEY_F: 70,             // Key: F | f
	KEY_G: 71,             // Key: G | g
	KEY_H: 72,             // Key: H | h
	KEY_I: 73,             // Key: I | i
	KEY_J: 74,             // Key: J | j
	KEY_K: 75,             // Key: K | k
	KEY_L: 76,             // Key: L | l
	KEY_M: 77,             // Key: M | m
	KEY_N: 78,             // Key: N | n
	KEY_O: 79,             // Key: O | o
	KEY_P: 80,             // Key: P | p
	KEY_Q: 81,             // Key: Q | q
	KEY_R: 82,             // Key: R | r
	KEY_S: 83,             // Key: S | s
	KEY_T: 84,             // Key: T | t
	KEY_U: 85,             // Key: U | u
	KEY_V: 86,             // Key: V | v
	KEY_W: 87,             // Key: W | w
	KEY_X: 88,             // Key: X | x
	KEY_Y: 89,             // Key: Y | y
	KEY_Z: 90,             // Key: Z | z
	KEY_LEFT_BRACKET: 91,  // Key: [
	KEY_BACKSLASH: 92,     // Key: '\'
	KEY_RIGHT_BRACKET: 93, // Key: ]
	KEY_GRAVE: 96,         // Key: `

	// Function keys
	KEY_SPACE: 32,          // Key: Space
	KEY_ESCAPE: 256,        // Key: Esc
	KEY_ENTER: 257,         // Key: Enter
	KEY_TAB: 258,           // Key: Tab
	KEY_BACKSPACE: 259,     // Key: Backspace
	KEY_INSERT: 260,        // Key: Ins
	KEY_DELETE: 261,        // Key: Del
	KEY_RIGHT: 262,         // Key: Cursor right
	KEY_LEFT: 263,          // Key: Cursor left
	KEY_DOWN: 264,          // Key: Cursor down
	KEY_UP: 265,            // Key: Cursor up
	KEY_PAGE_UP: 266,       // Key: Page up
	KEY_PAGE_DOWN: 267,     // Key: Page down
	KEY_HOME: 268,          // Key: Home
	KEY_END: 269,           // Key: End
	KEY_CAPS_LOCK: 280,     // Key: Caps lock
	KEY_SCROLL_LOCK: 281,   // Key: Scroll down
	KEY_NUM_LOCK: 282,      // Key: Num lock
	KEY_PRINT_SCREEN: 283,  // Key: Print screen
	KEY_PAUSE: 284,         // Key: Pause
	KEY_F1: 290,            // Key: F1
	KEY_F2: 291,            // Key: F2
	KEY_F3: 292,            // Key: F3
	KEY_F4: 293,            // Key: F4
	KEY_F5: 294,            // Key: F5
	KEY_F6: 295,            // Key: F6
	KEY_F7: 296,            // Key: F7
	KEY_F8: 297,            // Key: F8
	KEY_F9: 298,            // Key: F9
	KEY_F10: 299,           // Key: F10
	KEY_F11: 300,           // Key: F11
	KEY_F12: 301,           // Key: F12
	KEY_LEFT_SHIFT: 340,    // Key: Shift left
	KEY_LEFT_CONTROL: 341,  // Key: Control left
	KEY_LEFT_ALT: 342,      // Key: Alt left
	KEY_LEFT_SUPER: 343,    // Key: Super left
	KEY_RIGHT_SHIFT: 344,   // Key: Shift right
	KEY_RIGHT_CONTROL: 345, // Key: Control right
	KEY_RIGHT_ALT: 346,     // Key: Alt right
	KEY_RIGHT_SUPER: 347,   // Key: Super right
	KEY_KB_MENU: 348,       // Key: KB menu

	// Keypad keys
	KEY_KP_0: 320,        // Key: Keypad 0
	KEY_KP_1: 321,        // Key: Keypad 1
	KEY_KP_2: 322,        // Key: Keypad 2
	KEY_KP_3: 323,        // Key: Keypad 3
	KEY_KP_4: 324,        // Key: Keypad 4
	KEY_KP_5: 325,        // Key: Keypad 5
	KEY_KP_6: 326,        // Key: Keypad 6
	KEY_KP_7: 327,        // Key: Keypad 7
	KEY_KP_8: 328,        // Key: Keypad 8
	KEY_KP_9: 329,        // Key: Keypad 9
	KEY_KP_DECIMAL: 330,  // Key: Keypad .
	KEY_KP_DIVIDE: 331,   // Key: Keypad /
	KEY_KP_MULTIPLY: 332, // Key: Keypad *
	KEY_KP_SUBTRACT: 333, // Key: Keypad -
	KEY_KP_ADD: 334,      // Key: Keypad +
	KEY_KP_ENTER: 335,    // Key: Keypad Enter
	KEY_KP_EQUAL: 336,    // Key: Keypad :

	// Android key buttons
	KEY_BACK: 4,         // Key: Android back button
	KEY_MENU: 5,         // Key: Android menu button
	KEY_VOLUME_UP: 24,   // Key: Android volume up button
	KEY_VOLUME_DOWN: 25, // Key: Android volume down button
}

enum MouseButton {
	MOUSE_BUTTON_LEFT: 0,    // Mouse button left
	MOUSE_BUTTON_RIGHT: 1,   // Mouse button right
	MOUSE_BUTTON_MIDDLE: 2,  // Mouse button middle (pressed wheel)
	MOUSE_BUTTON_SIDE: 3,    // Mouse button side (advanced mouse device)
	MOUSE_BUTTON_EXTRA: 4,   // Mouse button extra (advanced mouse device)
	MOUSE_BUTTON_FORWARD: 5, // Mouse button forward (advanced mouse device)
	MOUSE_BUTTON_BACK: 6,    // Mouse button back (advanced mouse device)
}

enum MouseCursor {
	MOUSE_CURSOR_DEFAULT: 0,       // Default pointer shape
	MOUSE_CURSOR_ARROW: 1,         // Arrow shape
	MOUSE_CURSOR_IBEAM: 2,         // Text writing cursor shape
	MOUSE_CURSOR_CROSSHAIR: 3,     // Cross shape
	MOUSE_CURSOR_POINTING_HAND: 4, // Pointing hand cursor
	MOUSE_CURSOR_RESIZE_EW: 5,     // Horizontal resize/move arrow shape
	MOUSE_CURSOR_RESIZE_NS: 6,     // Vertical resize/move arrow shape
	MOUSE_CURSOR_RESIZE_NWSE: 7,   // Top-left to bottom-right diagonal resize/move arrow shape
	MOUSE_CURSOR_RESIZE_NESW: 8,   // The top-right to bottom-left diagonal resize/move arrow shape
	MOUSE_CURSOR_RESIZE_ALL: 9,    // The omnidirectional resize/move cursor shape
	MOUSE_CURSOR_NOT_ALLOWED: 10,  // The operation-not-allowed shape
}

enum GamepadButton {
	GAMEPAD_BUTTON_UNKNOWN: 0,       // Unknown button, just for error checking
	GAMEPAD_BUTTON_LEFT_FACE_UP,     // Gamepad left DPAD up button
	GAMEPAD_BUTTON_LEFT_FACE_RIGHT,  // Gamepad left DPAD right button
	GAMEPAD_BUTTON_LEFT_FACE_DOWN,   // Gamepad left DPAD down button
	GAMEPAD_BUTTON_LEFT_FACE_LEFT,   // Gamepad left DPAD left button
	GAMEPAD_BUTTON_RIGHT_FACE_UP,    // Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
	GAMEPAD_BUTTON_RIGHT_FACE_RIGHT, // Gamepad right button right (i.e. PS3: Circle, Xbox: B)
	GAMEPAD_BUTTON_RIGHT_FACE_DOWN,  // Gamepad right button down (i.e. PS3: Cross, Xbox: A)
	GAMEPAD_BUTTON_RIGHT_FACE_LEFT,  // Gamepad right button left (i.e. PS3: Square, Xbox: X)
	GAMEPAD_BUTTON_LEFT_TRIGGER_1,   // Gamepad top/back trigger left (first), it could be a trailing button
	GAMEPAD_BUTTON_LEFT_TRIGGER_2,   // Gamepad top/back trigger left (second), it could be a trailing button
	GAMEPAD_BUTTON_RIGHT_TRIGGER_1,  // Gamepad top/back trigger right (first), it could be a trailing button
	GAMEPAD_BUTTON_RIGHT_TRIGGER_2,  // Gamepad top/back trigger right (second), it could be a trailing button
	GAMEPAD_BUTTON_MIDDLE_LEFT,      // Gamepad center buttons, left one (i.e. PS3: Select)
	GAMEPAD_BUTTON_MIDDLE,           // Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
	GAMEPAD_BUTTON_MIDDLE_RIGHT,     // Gamepad center buttons, right one (i.e. PS3: Start)
	GAMEPAD_BUTTON_LEFT_THUMB,       // Gamepad joystick pressed button left
	GAMEPAD_BUTTON_RIGHT_THUMB,      // Gamepad joystick pressed button right
}

enum GamepadAxis {
	GAMEPAD_AXIS_LEFT_X: 0,        // Gamepad left stick X axis
	GAMEPAD_AXIS_LEFT_Y: 1,        // Gamepad left stick Y axis
	GAMEPAD_AXIS_RIGHT_X: 2,       // Gamepad right stick X axis
	GAMEPAD_AXIS_RIGHT_Y: 3,       // Gamepad right stick Y axis
	GAMEPAD_AXIS_LEFT_TRIGGER: 4,  // Gamepad back trigger left, pressure level: [1..-1]
	GAMEPAD_AXIS_RIGHT_TRIGGER: 5, // Gamepad back trigger right, pressure level: [1..-1]
}

enum MaterialMapIndex {
	MATERIAL_MAP_ALBEDO: 0,  // Albedo material (same as: MATERIAL_MAP_DIFFUSE)
	MATERIAL_MAP_METALNESS,  // Metalness material (same as: MATERIAL_MAP_SPECULAR)
	MATERIAL_MAP_NORMAL,     // Normal material
	MATERIAL_MAP_ROUGHNESS,  // Roughness material
	MATERIAL_MAP_OCCLUSION,  // Ambient occlusion material
	MATERIAL_MAP_EMISSION,   // Emission material
	MATERIAL_MAP_HEIGHT,     // Heightmap material
	MATERIAL_MAP_CUBEMAP,    // Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
	MATERIAL_MAP_IRRADIANCE, // Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
	MATERIAL_MAP_PREFILTER,  // Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
	MATERIAL_MAP_BRDF,       // Brdf material
}

//#define MATERIAL_MAP_DIFFUSE      MATERIAL_MAP_ALBEDO
//#define MATERIAL_MAP_SPECULAR     MATERIAL_MAP_METALNESS
//

enum ShaderLocationIndex {
	SHADER_LOC_VERTEX_POSITION: 0, // Shader location: vertex attribute: position
	SHADER_LOC_VERTEX_TEXCOORD01,  // Shader location: vertex attribute: texcoord01
	SHADER_LOC_VERTEX_TEXCOORD02,  // Shader location: vertex attribute: texcoord02
	SHADER_LOC_VERTEX_NORMAL,      // Shader location: vertex attribute: normal
	SHADER_LOC_VERTEX_TANGENT,     // Shader location: vertex attribute: tangent
	SHADER_LOC_VERTEX_COLOR,       // Shader location: vertex attribute: color
	SHADER_LOC_MATRIX_MVP,         // Shader location: matrix uniform: model-view-projection
	SHADER_LOC_MATRIX_VIEW,        // Shader location: matrix uniform: view (camera transform)
	SHADER_LOC_MATRIX_PROJECTION,  // Shader location: matrix uniform: projection
	SHADER_LOC_MATRIX_MODEL,       // Shader location: matrix uniform: model (transform)
	SHADER_LOC_MATRIX_NORMAL,      // Shader location: matrix uniform: normal
	SHADER_LOC_VECTOR_VIEW,        // Shader location: vector uniform: view
	SHADER_LOC_COLOR_DIFFUSE,      // Shader location: vector uniform: diffuse color
	SHADER_LOC_COLOR_SPECULAR,     // Shader location: vector uniform: specular color
	SHADER_LOC_COLOR_AMBIENT,      // Shader location: vector uniform: ambient color
	SHADER_LOC_MAP_ALBEDO,         // Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
	SHADER_LOC_MAP_METALNESS,      // Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
	SHADER_LOC_MAP_NORMAL,         // Shader location: sampler2d texture: normal
	SHADER_LOC_MAP_ROUGHNESS,      // Shader location: sampler2d texture: roughness
	SHADER_LOC_MAP_OCCLUSION,      // Shader location: sampler2d texture: occlusion
	SHADER_LOC_MAP_EMISSION,       // Shader location: sampler2d texture: emission
	SHADER_LOC_MAP_HEIGHT,         // Shader location: sampler2d texture: height
	SHADER_LOC_MAP_CUBEMAP,        // Shader location: samplerCube texture: cubemap
	SHADER_LOC_MAP_IRRADIANCE,     // Shader location: samplerCube texture: irradiance
	SHADER_LOC_MAP_PREFILTER,      // Shader location: samplerCube texture: prefilter
	SHADER_LOC_MAP_BRDF,           // Shader location: sampler2d texture: brdf
	SHADER_LOC_VERTEX_BONEIDS,     // Shader location: vertex attribute: boneIds
	SHADER_LOC_VERTEX_BONEWEIGHTS, // Shader location: vertex attribute: boneWeights
	SHADER_LOC_BONE_MATRICES,      // Shader location: array of matrices uniform: boneMatrices
}

//#define SHADER_LOC_MAP_DIFFUSE      SHADER_LOC_MAP_ALBEDO
//#define SHADER_LOC_MAP_SPECULAR     SHADER_LOC_MAP_METALNESS

enum ShaderUniformDataType {
	SHADER_UNIFORM_FLOAT: 0,  // Shader uniform type: float
	SHADER_UNIFORM_VEC2,      // Shader uniform type: vec2 (2 float)
	SHADER_UNIFORM_VEC3,      // Shader uniform type: vec3 (3 float)
	SHADER_UNIFORM_VEC4,      // Shader uniform type: vec4 (4 float)
	SHADER_UNIFORM_INT,       // Shader uniform type: int
	SHADER_UNIFORM_IVEC2,     // Shader uniform type: ivec2 (2 int)
	SHADER_UNIFORM_IVEC3,     // Shader uniform type: ivec3 (3 int)
	SHADER_UNIFORM_IVEC4,     // Shader uniform type: ivec4 (4 int)
	SHADER_UNIFORM_SAMPLER2D, // Shader uniform type: sampler2d
}

enum ShaderAttributeDataType {
	SHADER_ATTRIB_FLOAT: 0, // Shader attribute type: float
	SHADER_ATTRIB_VEC2,     // Shader attribute type: vec2 (2 float)
	SHADER_ATTRIB_VEC3,     // Shader attribute type: vec3 (3 float)
	SHADER_ATTRIB_VEC4,     // Shader attribute type: vec4 (4 float)
}

enum PixelFormat {
	PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: 1, // 8 bit per pixel (no alpha)
	PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA,   // 8*2 bpp (2 channels)
	PIXELFORMAT_UNCOMPRESSED_R5G6B5,       // 16 bpp
	PIXELFORMAT_UNCOMPRESSED_R8G8B8,       // 24 bpp
	PIXELFORMAT_UNCOMPRESSED_R5G5B5A1,     // 16 bpp (1 bit alpha)
	PIXELFORMAT_UNCOMPRESSED_R4G4B4A4,     // 16 bpp (4 bit alpha)
	PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,     // 32 bpp
	PIXELFORMAT_UNCOMPRESSED_R32,          // 32 bpp (1 channel - float)
	PIXELFORMAT_UNCOMPRESSED_R32G32B32,    // 32*3 bpp (3 channels - float)
	PIXELFORMAT_UNCOMPRESSED_R32G32B32A32, // 32*4 bpp (4 channels - float)
	PIXELFORMAT_UNCOMPRESSED_R16,          // 16 bpp (1 channel - half float)
	PIXELFORMAT_UNCOMPRESSED_R16G16B16,    // 16*3 bpp (3 channels - half float)
	PIXELFORMAT_UNCOMPRESSED_R16G16B16A16, // 16*4 bpp (4 channels - half float)
	PIXELFORMAT_COMPRESSED_DXT1_RGB,       // 4 bpp (no alpha)
	PIXELFORMAT_COMPRESSED_DXT1_RGBA,      // 4 bpp (1 bit alpha)
	PIXELFORMAT_COMPRESSED_DXT3_RGBA,      // 8 bpp
	PIXELFORMAT_COMPRESSED_DXT5_RGBA,      // 8 bpp
	PIXELFORMAT_COMPRESSED_ETC1_RGB,       // 4 bpp
	PIXELFORMAT_COMPRESSED_ETC2_RGB,       // 4 bpp
	PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA,  // 8 bpp
	PIXELFORMAT_COMPRESSED_PVRT_RGB,       // 4 bpp
	PIXELFORMAT_COMPRESSED_PVRT_RGBA,      // 4 bpp
	PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA,  // 8 bpp
	PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA,  // 2 bpp
}

enum TextureFilter {
	TEXTURE_FILTER_POINT: 0,        // No filter, just pixel approximation
	TEXTURE_FILTER_BILINEAR,        // Linear filtering
	TEXTURE_FILTER_TRILINEAR,       // Trilinear filtering (linear with mipmaps)
	TEXTURE_FILTER_ANISOTROPIC_4X,  // Anisotropic filtering 4x
	TEXTURE_FILTER_ANISOTROPIC_8X,  // Anisotropic filtering 8x
	TEXTURE_FILTER_ANISOTROPIC_16X, // Anisotropic filtering 16x
}

enum TextureWrap {
	TEXTURE_WRAP_REPEAT: 0,     // Repeats texture in tiled mode
	TEXTURE_WRAP_CLAMP,         // Clamps texture to edge pixel in tiled mode
	TEXTURE_WRAP_MIRROR_REPEAT, // Mirrors and repeats the texture in tiled mode
	TEXTURE_WRAP_MIRROR_CLAMP,  // Mirrors and clamps to border the texture in tiled mode
}

enum CubemapLayout {
	CUBEMAP_LAYOUT_AUTO_DETECT: 0,      // Automatically detect layout type
	CUBEMAP_LAYOUT_LINE_VERTICAL,       // Layout is defined by a vertical line with faces
	CUBEMAP_LAYOUT_LINE_HORIZONTAL,     // Layout is defined by a horizontal line with faces
	CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR, // Layout is defined by a 3x4 cross with cubemap faces
	CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE, // Layout is defined by a 4x3 cross with cubemap faces
}

enum FontType {
	FONT_DEFAULT: 0, // Default font generation, anti-aliased
	FONT_BITMAP,     // Bitmap font generation, no anti-aliasing
	FONT_SDF,        // SDF font generation, requires external shader
}

enum BlendMode {
	BLEND_ALPHA: 0,          // Blend textures considering alpha (default)
	BLEND_ADDITIVE,          // Blend textures adding colors
	BLEND_MULTIPLIED,        // Blend textures multiplying colors
	BLEND_ADD_COLORS,        // Blend textures adding colors (alternative)
	BLEND_SUBTRACT_COLORS,   // Blend textures subtracting colors (alternative)
	BLEND_ALPHA_PREMULTIPLY, // Blend premultiplied textures considering alpha
	BLEND_CUSTOM,            // Blend textures using custom src/dst factors (use rlSetBlendFactors())
	BLEND_CUSTOM_SEPARATE,   // Blend textures using custom rgb/alpha separate src/dst factors (use rlSetBlendFactorsSeparate())
}

enum Gesture {
	GESTURE_NONE: 0,         // No gesture
	GESTURE_TAP: 1,          // Tap gesture
	GESTURE_DOUBLETAP: 2,    // Double tap gesture
	GESTURE_HOLD: 4,         // Hold gesture
	GESTURE_DRAG: 8,         // Drag gesture
	GESTURE_SWIPE_RIGHT: 16, // Swipe right gesture
	GESTURE_SWIPE_LEFT: 32,  // Swipe left gesture
	GESTURE_SWIPE_UP: 64,    // Swipe up gesture
	GESTURE_SWIPE_DOWN: 128, // Swipe down gesture
	GESTURE_PINCH_IN: 256,   // Pinch in gesture
	GESTURE_PINCH_OUT: 512,  // Pinch out gesture
}

enum CameraMode {
	CAMERA_CUSTOM: 0,    // Camera custom, controlled by user (UpdateCamera() does nothing)
	CAMERA_FREE,         // Camera free mode
	CAMERA_ORBITAL,      // Camera orbital, around target, zoom supported
	CAMERA_FIRST_PERSON, // Camera first person
	CAMERA_THIRD_PERSON, // Camera third person
}

enum CameraProjection {
	CAMERA_PERSPECTIVE: 0, // Perspective projection
	CAMERA_ORTHOGRAPHIC,   // Orthographic projection
}

enum NPatchLayout {
	NPATCH_NINE_PATCH: 0,          // Npatch layout: 3x3 tiles
	NPATCH_THREE_PATCH_VERTICAL,   // Npatch layout: 1x3 tiles
	NPATCH_THREE_PATCH_HORIZONTAL, // Npatch layout: 3x1 tiles
}

extern type Void: uintptr
type Void = extern.Void

extern fn ConvertBytesToVoidPtr(bytes: *extern.char, size: int): Void
fn ConvertBytesToVoidPtr(bytes: *extern.char): Void {
	let size = unsafe { getLenCppChar(bytes) }
	ret unsafe { extern.ConvertBytesToVoidPtr(bytes, size) }
}

unsafe fn strToCharPtr(s: str): *extern.char {
	ret (*extern.char)(&s[0])
}

unsafe fn ptrCharToStr(c: *extern.char): str {
	if c == nil {
		ret ""
	}
	let mut s = ""
	let mut i = 0
	for int(c[i]) != 0; i++ {
		s += str(c[i])
	}
	ret s
}

unsafe fn ptrU8ToBytes(raw: *u8): []byte {
	if raw == nil {
		ret nil
	}
	let mut data = make([]byte, 0, 1)
	let mut i = 0
	for int(raw[i]) != 0; i++ {
		data = append(data, byte(raw[i]))
	}
	ret data
}
unsafe fn getLenCppChar(ch: *extern.char): int {
	if ch == nil {
		ret 0
	}
	let mut out: int = 0
	let mut i = 0
	for int(ch[i]) != 0; i++ {
		out = i
	}
	ret out
}

//MatrixToFloat

//Vector3ToFloat

//Vector2Zero
fn Vector2Zero():Vector2{
   ret Vector2{x:0,y:0}
}
//Vector2One
fn Vector2One():Vector2{
   ret Vector2{1,1}
}

//Vector2Add
fn Vector2Add(v1:Vector2,v2:Vector2): Vector2{
   ret Vector2{v1.x+v2.x,v1.y+v2.y}
}

//Vector2AddValue
fn Vector2AddValue(v1: Vector2, add: f32):Vector2{
   ret Vector2{v1.x+add,v1.y+add}
}

//Vector2Subtract
fn Vector2Subtract(v1:Vector2,v2:Vector2): Vector2{
   ret Vector2{v1.x-v2.x,v1.y-v2.y}
}

//Vector2SubtractValue
fn Vector2SubtractValue(v1: Vector2, add: f32):Vector2{
   ret Vector2{v1.x-add,v1.y-add}
}

//Vector2Length
fn Vector2Length(v:Vector2):f32{
   ret f32(math::Sqrt(f64(v.x*v.x+v.y*v.y)))
}

//Vector3Add
fn Vector3Add(v1: Vector3, v2: Vector3):Vector3{
   ret Vector3{x:v1.x+v2.x,y:v1.y+v2.y,z:v1.z+v2.z}
}

// Window-related functions

extern unsafe fn InitWindow(w: int, h: int, title: *extern.char)
fn InitWindow(w: int, h: int, title: str) {
	unsafe { extern.InitWindow(w, h, (*extern.char)(&title[0])) }
}

extern unsafe fn CloseWindow()
fn CloseWindow() {
	unsafe { extern.CloseWindow() }
}

extern unsafe fn WindowShouldClose(): bool
fn WindowShouldClose(): bool {
	ret unsafe { extern.WindowShouldClose() }
}

extern unsafe fn IsWindowReady(): bool
fn IsWindowReady(): bool {
	ret unsafe { extern.IsWindowReady() }
}

// RLAPI bool IsWindowFullscreen(void);                              // Check if window is currently fullscreen
extern unsafe fn IsWindowFullscreen(): bool
fn IsWindowFullscreen(): bool {
	ret unsafe { extern.IsWindowFullscreen() }
}

// RLAPI bool IsWindowHidden(void);                                  // Check if window is currently hidden
extern unsafe fn IsWindowHidden(): bool
fn IsWindowHidden(): bool {
	ret unsafe { extern.IsWindowHidden() }
}

// RLAPI bool IsWindowMinimized(void): bool;                               // Check if window is currently minimized
extern unsafe fn IsWindowMinimized(): bool
fn IsWindowMinimized(): bool {
	ret unsafe { extern.IsWindowMinimized() }
}

// RLAPI bool IsWindowMaximized(void);                               // Check if window is currently maximized
extern unsafe fn IsWindowMaximized(): bool
fn IsWindowMaximized(): bool {
	ret unsafe { extern.IsWindowMaximized() }
}

// RLAPI bool IsWindowFocused(void);                                 // Check if window is currently focused
extern unsafe fn IsWindowFocused(): bool
fn IsWindowFocused(): bool {
	ret unsafe { extern.IsWindowFocused() }
}

// RLAPI bool IsWindowResized(void);                                 // Check if window has been resized last frame
extern unsafe fn IsWindowResized(): bool
fn IsWindowResized(): bool {
	ret unsafe { extern.IsWindowResized() }
}

// RLAPI bool IsWindowState(unsigned int flag);                      // Check if one specific window flag is enabled
extern unsafe fn IsWindowState(flag: u32): bool
fn IsWindowState(flag: u32): bool {
	ret unsafe { extern.IsWindowState(flag) }
}

// RLAPI void SetWindowState(unsigned int flags);                    // Set window configuration state using flags
extern unsafe fn SetWindowState(flags: u32)
fn SetWindowState(flags: u32) {
	unsafe { extern.SetWindowState(flags) }
}

// RLAPI void ClearWindowState(unsigned int flags);                  // Clear window configuration state flags
extern unsafe fn ClearWindowState(flags: u32)
fn ClearWindowState(flags: u32) {
	unsafe { extern.ClearWindowState(flags) }
}

// RLAPI void ToggleFullscreen(void);                                // Toggle window state: fullscreen/windowed, resizes monitor to match window resolution
extern unsafe fn ToggleFullscreen()
fn ToggleFullscreen() {
	unsafe { extern.ToggleFullscreen() }
}

// RLAPI void ToggleBorderlessWindowed(void);                        // Toggle window state: borderless windowed, resizes window to match monitor resolution
extern unsafe fn ToggleBorderlessWindowed()
fn ToggleBorderlessWindowed() {
	unsafe { extern.ToggleBorderlessWindowed() }
}

// RLAPI void MaximizeWindow(void);                                  // Set window state: maximized, if resizable
extern unsafe fn MaximizeWindow()
fn MaximizeWindow() {
	unsafe { extern.MaximizeWindow() }
}

// RLAPI void MinimizeWindow(void);                                  // Set window state: minimized, if resizable
extern unsafe fn MinimizeWindow()
fn MinimizeWindow() {
	unsafe { extern.MinimizeWindow() }
}

// RLAPI void RestoreWindow(void);                                   // Set window state: not minimized/maximized
extern unsafe fn RestoreWindow()
fn RestoreWindow() {
	unsafe { extern.RestoreWindow() }
}

// RLAPI void SetWindowIcon(Image image);                            // Set icon for window (single image, RGBA 32bit)
extern unsafe fn SetWindowIcon(image: extern.Image)
fn SetWindowIcon(image: Image) {
	unsafe { extern.SetWindowIcon(image) }
}

// RLAPI void SetWindowIcons(Image *images, int count);              // Set icon for window (multiple images, RGBA 32bit)
extern unsafe fn SetWindowIcons(images: *extern.Image, count: int)
fn SetWindowIcons(images: []Image, count: int) {
	unsafe { extern.SetWindowIcons(&images[0], count) }
}

// RLAPI void SetWindowTitle(const char *title);                     // Set title for window
extern unsafe fn SetWindowTitle(images: *extern.char)
fn SetWindowTitle(title: str) {
	unsafe { extern.SetWindowTitle(strToCharPtr(title)) }
}

//RLAPI void SetWindowPosition(int x, int y);                       // Set window position on screen
extern unsafe fn SetWindowPosition(x: int, y: int)
fn SetWindowPosition(x: int, y: int) {
	unsafe { extern.SetWindowPosition(x, y) }
}

// RLAPI void SetWindowMonitor(int monitor);                         // Set monitor for the current window
extern unsafe fn SetWindowMonitor(monitor: int)
fn SetWindowMonitor(monitor: int) {
	unsafe { extern.SetWindowMonitor(monitor) }
}

// RLAPI void SetWindowMinSize(int width, int height);               // Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
extern unsafe fn SetWindowMinSize(w: int, h: int)
fn SetWindowMinSize(w: int, h: int) {
	unsafe { extern.SetWindowMinSize(w, h) }
}

// RLAPI void SetWindowMaxSize(int width, int height);               // Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE)
extern unsafe fn SetWindowMaxSize(w: int, h: int)
fn SetWindowMaxSize(w: int, h: int) {
	unsafe { extern.SetWindowMaxSize(w, h) }
}

// RLAPI void SetWindowSize(int width, int height);                  // Set window dimensions
extern unsafe fn SetWindowSize(w: int, h: int)
fn SetWindowSize(w: int, h: int) {
	unsafe { extern.SetWindowSize(w, h) }
}

// RLAPI void SetWindowOpacity(float opacity);                       // Set window opacity [0.0f..1.0f]
extern unsafe fn SetWindowOpacity(opacity: f32)
fn SetWindowOpacity(opacity: f32) {
	unsafe { extern.SetWindowOpacity(opacity) }
}

// RLAPI void SetWindowFocused(void);                                // Set window focused
extern unsafe fn SetWindowFocused()
fn SetWindowFocused() {
	unsafe { extern.SetWindowFocused() }
}

// RLAPI void *GetWindowHandle(void);                                // Get native window handle
// TODO: check this function
//extern unsafe fn GetWindowHandle(): *any
//fn GetWindowHandle():*any{
//     ret unsafe {(*any)(extern.GetWindowHandle())}
//}

// RLAPI int GetScreenWidth(void);                                   // Get current screen width
extern unsafe fn GetScreenWidth(): int
fn GetScreenWidth(): int {
	ret unsafe { extern.GetScreenWidth() }
}

// RLAPI int GetScreenHeight(void);                                  // Get current screen height
extern unsafe fn GetScreenHeight(): int
fn GetScreenHeight(): int {
	ret unsafe { extern.GetScreenHeight() }
}

// RLAPI int GetRenderWidth(void);                                   // Get current render width (it considers HiDPI)
extern unsafe fn GetRenderWidth(): int
fn GetRenderWidth(): int {
	ret unsafe { extern.GetRenderWidth() }
}

// RLAPI int GetRenderHeight(void);                                  // Get current render height (it considers HiDPI)
extern unsafe fn GetRenderHeight(): int
fn GetRenderHeight(): int {
	ret unsafe { extern.GetRenderHeight() }
}

// RLAPI int GetMonitorCount(void);                                  // Get number of connected monitors
extern unsafe fn GetMonitorCount(): int
fn GetMonitorCount(): int {
	ret unsafe { extern.GetMonitorCount() }
}

// RLAPI int GetCurrentMonitor(void);                                // Get current monitor where window is placed
extern unsafe fn GetCurrentMonitor(): int
fn GetCurrentMonitor(): int {
	ret unsafe { extern.GetCurrentMonitor() }
}

// RLAPI Vector2 GetMonitorPosition(int monitor);                    // Get specified monitor position
extern unsafe fn GetMonitorPosition(monitor: int): Vector2
fn GetMonitorPosition(monitor: int): Vector2 {
	ret unsafe { extern.GetMonitorPosition(monitor) }
}

// RLAPI int GetMonitorWidth(int monitor);                           // Get specified monitor width (current video mode used by monitor)
extern unsafe fn GetMonitorWidth(monitor: int): int
fn GetMonitorWidth(monitor: int): int {
	ret unsafe { extern.GetMonitorWidth(monitor) }
}

// RLAPI int GetMonitorHeight(int monitor);                          // Get specified monitor height (current video mode used by monitor)
extern unsafe fn GetMonitorHeight(monitor: int): int
fn GetMonitorHeight(monitor: int): int {
	ret unsafe { extern.GetMonitorHeight(monitor) }
}

// RLAPI int GetMonitorPhysicalWidth(int monitor);                   // Get specified monitor physical width in millimetres
extern unsafe fn GetMonitorPhysicalWidth(monitor: int): int
fn GetMonitorPhysicalWidth(monitor: int): int {
	ret unsafe { extern.GetMonitorPhysicalWidth(monitor) }
}

// RLAPI int GetMonitorPhysicalHeight(int monitor);                  // Get specified monitor physical height in millimetres
extern unsafe fn GetMonitorPhysicalHeight(monitor: int): int
fn GetMonitorPhysicalHeight(monitor: int): int {
	ret unsafe { extern.GetMonitorPhysicalHeight(monitor) }
}

// RLAPI int GetMonitorRefreshRate(int monitor);                     // Get specified monitor refresh rate
extern unsafe fn GetMonitorRefreshRate(monitor: int): int
fn GetMonitorRefreshRate(monitor: int): int {
	ret unsafe { extern.GetMonitorRefreshRate(monitor) }
}

// RLAPI Vector2 GetWindowPosition(void);                            // Get window position XY on monitor
extern unsafe fn GetWindowPosition(): Vector2
fn GetWindowPosition(): Vector2 {
	ret unsafe { extern.GetWindowPosition() }
}

// RLAPI Vector2 GetWindowScaleDPI(void);                            // Get window scale DPI factor
extern unsafe fn GetWindowScaleDPI(): Vector2
fn GetWindowScaleDPI(): Vector2 {
	ret unsafe { extern.GetWindowScaleDPI() }
}

// RLAPI const char *GetMonitorName(int monitor);                    // Get the human-readable, UTF-8 encoded name of the specified monitor
extern unsafe fn GetMonitorName(monitor: int): str
fn GetMonitorName(monitor: int): str {
	//let raw = unsafe {extern.GetMonitorName(monitor)}
	//ret unsafe {ptrCharToStr(raw)}
	ret unsafe { extern.GetMonitorName(monitor) }
}

// RLAPI void SetClipboardText(const char *text);                    // Set clipboard text content
extern unsafe fn SetClipboardText(text: *extern.char)
fn SetClipboardText(text: str) {
	unsafe { extern.SetClipboardText(strToCharPtr(text)) }
}

// RLAPI const char *GetClipboardText(void);                         // Get clipboard text content
extern unsafe fn GetClipboardText(): str
fn GetClipboardText(): str {
	ret unsafe { extern.GetClipboardText() }
}

// RLAPI Image GetClipboardImage(void);                              // Get clipboard image content
extern unsafe fn GetClipboardImage(): Image
fn GetClipboardImage(): Image {
	ret unsafe { extern.GetClipboardImage() }
}

// RLAPI void EnableEventWaiting(void);                              // Enable waiting for events on EndDrawing(), no automatic event polling
extern unsafe fn EnableEventWaiting()
fn EnableEventWaiting() {
	unsafe { extern.EnableEventWaiting() }
}

// RLAPI void DisableEventWaiting(void);                             // Disable waiting for events on EndDrawing(), automatic events polling
extern unsafe fn DisableEventWaiting()
fn DisableEventWaiting() {
	unsafe { extern.DisableEventWaiting() }
}

// Cursor-related functions
//********************************************************************

//RLAPI void ShowCursor(void);                                      // Shows cursor
extern unsafe fn ShowCursor()
fn ShowCursor() {
	unsafe { extern.ShowCursor() }
}

//RLAPI void HideCursor(void);                                      // Hides cursor
extern unsafe fn HideCursor()
fn HideCursor() {
	unsafe { extern.HideCursor() }
}

//RLAPI bool IsCursorHidden(void);                                  // Check if cursor is not visible
extern unsafe fn IsCursorHidden(): bool
fn IsCursorHidden(): bool {
	ret unsafe { extern.IsCursorHidden() }
}

//RLAPI void EnableCursor(void);                                    // Enables cursor (unlock cursor)
extern unsafe fn EnableCursor()
fn EnableCursor() {
	unsafe { extern.EnableCursor() }
}

//RLAPI void DisableCursor(void);                                   // Disables cursor (lock cursor)
extern unsafe fn DisableCursor()
fn DisableCursor() {
	unsafe { extern.DisableCursor() }
}

//RLAPI bool IsCursorOnScreen(void);                                // Check if cursor is on the screen
extern unsafe fn IsCursorOnScreen(): bool
fn IsCursorOnScreen(): bool {
	ret unsafe { extern.IsCursorOnScreen() }
}

//*********************************************************
// VR stereo config functions for VR simulator
// RLAPI VrStereoConfig LoadVrStereoConfig(VrDeviceInfo device);     // Load VR stereo config for VR simulator device parameters
extern unsafe fn LoadVrStereoConfig(device: VrDeviceInfo): VrStereoConfig
fn LoadVrStereoConfig(device: VrDeviceInfo): VrStereoConfig {
	ret unsafe { extern.LoadVrStereoConfig(device) }
}

// RLAPI void UnloadVrStereoConfig(VrStereoConfig config);           // Unload VR stereo config
extern unsafe fn UnloadVrStereoConfig(config: VrStereoConfig)
fn UnloadVrStereoConfig(config: VrStereoConfig) {
	unsafe { extern.UnloadVrStereoConfig(config) }
}

//**********************************************************************
// RLAPI Ray GetScreenToWorldRay(Vector2 position, Camera camera);         // Get a ray trace from screen position (i.e mouse)
extern unsafe fn GetScreenToWorldRay(position: Vector2, camera: Camera): Ray
fn GetScreenToWorldRay(position: Vector2, camera: Camera): Ray {
	ret unsafe { extern.GetScreenToWorldRay(position, camera) }
}

// RLAPI Ray GetScreenToWorldRayEx(Vector2 position, Camera camera, int width, int height); // Get a ray trace from screen position (i.e mouse) in a viewport
extern unsafe fn GetScreenToWorldRayEx(position: Vector2, camera: Camera, width: i32, height: i32): Ray
fn GetScreenToWorldRayEx(position: Vector2, camera: Camera, width: i32, height: i32): Ray {
	ret unsafe { extern.GetScreenToWorldRayEx(position, camera, width, height) }
}

// RLAPI Vector2 GetWorldToScreen(Vector3 position, Camera camera);        // Get the screen space position for a 3d world space position
extern unsafe fn GetWorldToScreen(position: Vector3, camera: Camera): Vector2
fn GetWorldToScreen(position: Vector3, camera: Camera): Vector2 {
	ret unsafe { extern.GetWorldToScreen(position, camera) }
}

// RLAPI Vector2 GetWorldToScreenEx(Vector3 position, Camera camera, int width, int height); // Get size position for a 3d world space position
extern unsafe fn GetWorldToScreenEx(position: Vector3, camera: Camera, width: i32, height: i32): Vector2
fn GetWorldToScreenEx(position: Vector3, camera: Camera, width: i32, height: i32): Vector2 {
	ret unsafe { extern.GetWorldToScreenEx(position, camera, width, height) }
}

// RLAPI Vector2 GetWorldToScreen2D(Vector2 position, Camera2D camera);    // Get the screen space position for a 2d camera world space position
extern unsafe fn GetWorldToScreen2D(position: Vector2, camera: Camera2D): Vector2
fn GetWorldToScreen2D(position: Vector2, camera: Camera2D): Vector2 {
	ret unsafe { extern.GetWorldToScreen2D(position, camera) }
}

// RLAPI Vector2 GetScreenToWorld2D(Vector2 position, Camera2D camera);    // Get the world space position for a 2d camera screen space position
extern unsafe fn GetScreenToWorld2D(position: Vector2, camera: Camera2D): Vector2
fn GetScreenToWorld2D(position: Vector2, camera: Camera2D): Vector2 {
	ret unsafe { extern.GetScreenToWorld2D(position, camera) }
}

// RLAPI Matrix GetCameraMatrix(Camera camera);                            // Get camera transform matrix (view matrix)
extern unsafe fn GetCameraMatrix(camera: Camera): Matrix
fn GetCameraMatrix(camera: Camera): Matrix {
	ret unsafe { extern.GetCameraMatrix(camera) }
}

// RLAPI Matrix GetCameraMatrix2D(Camera2D camera);                        // Get camera 2d transform matrix
extern unsafe fn GetCameraMatrix2D(camera: Camera2D): Matrix
fn GetCameraMatrix2D(camera: Camera2D): Matrix {
	ret unsafe { extern.GetCameraMatrix2D(camera) }
}

// Timing-related functions
// RLAPI void SetTargetFPS(int fps);                                 // Set target FPS (maximum)
extern unsafe fn SetTargetFPS(fps: i32)
fn SetTargetFPS(fps: i32) {
	unsafe { extern.SetTargetFPS(fps) }
}

// RLAPI float GetFrameTime(void);                                   // Get time in seconds for last frame drawn (delta time)
extern unsafe fn GetFrameTime(): f32
fn GetFrameTime(): f32 {
	ret unsafe { extern.GetFrameTime() }
}

// RLAPI double GetTime(void);                                       // Get elapsed time in seconds since InitWindow()
extern unsafe fn GetTime(): f32
fn GetTime(): f32 {
	ret unsafe { extern.GetTime() }
}

// RLAPI int GetFPS(void);                                           // Get current FPS
extern unsafe fn GetFPS(): i32
fn GetFPS(): i32 {
	ret unsafe { extern.GetFPS() }
}

//*******************************************************
// RLAPI void SwapScreenBuffer(void);                                // Swap back buffer with front buffer (screen drawing)
extern unsafe fn SwapScreenBuffer()
fn SwapScreenBuffer() {
	unsafe { extern.SwapScreenBuffer() }
}

// RLAPI void PollInputEvents(void);                                 // Register all input events
extern unsafe fn PollInputEvents()
fn PollInputEvents() {
	unsafe { extern.PollInputEvents() }
}

// RLAPI void WaitTime(double seconds);                              // Wait for some time (halt program execution)
extern unsafe fn WaitTime(seconds: f32)
fn WaitTime(seconds: f32) {
	unsafe { extern.WaitTime(seconds) }
}

// Random values generation functions
// RLAPI void SetRandomSeed(unsigned int seed)                      // Set the seed for the random number generator
extern unsafe fn SetRandomSeed(seed: u32)
fn SetRandomSeed(seed: u32) {
	unsafe { extern.SetRandomSeed(seed) }
}

// RLAPI int GetRandomValue(int min, int max)                       // Get a random value between min and max (both included)
extern unsafe fn GetRandomValue(min: i32, max: i32)
fn GetRandomValue(min: i32, max: i32) {
	unsafe { extern.GetRandomValue(min, max) }
}

// RLAPI int *LoadRandomSequence(unsigned int count, int min, int max) // Load random values sequence, no values repeated
extern unsafe fn LoadRandomSequence(count: u32, min: i32, max: i32): *i32
fn LoadRandomSequence(count: u32, min: i32, max: i32): *i32 {
	let arr = unsafe { extern.LoadRandomSequence(count, min, max) }
	ret unsafe { &arr[0] }
}

// RLAPI void UnloadRandomSequence(int *sequence)                   // Unload random values sequence
extern unsafe fn UnloadRandomSequence(sequence: *i32)
fn UnloadRandomSequence(sequence: []i32) {
	unsafe { extern.UnloadRandomSequence(&sequence[0]) }
}

// Misc. functions
// RLAPI void TakeScreenshot(const char *fileName)                  // Takes a screenshot of current screen (filename extension defines format)
extern unsafe fn TakeScreenshot(fileName: *extern.char)
fn TakeScreenshot(fileName: str) {
	unsafe { extern.TakeScreenshot(strToCharPtr(fileName)) }
}

// RLAPI void SetConfigFlags(unsigned int flags)                    // Setup init configuration flags (view FLAGS)
extern unsafe fn SetConfigFlags(flags: u32)
fn SetConfigFlags(flags: u32) {
	unsafe { extern.SetConfigFlags(flags) }
}

// RLAPI void OpenURL(const char *url)                              // Open URL with default system browser (if available)
extern unsafe fn OpenURL(url: *extern.char)
fn OpenURL(url: str) {
	unsafe { extern.OpenURL(strToCharPtr(url)) }
}

// NOTE: Following functions implemented in module [utils]
//------------------------------------------------------------------
// RLAPI void TraceLog(int logLevel, const char *text, ...)         // Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)
extern unsafe fn TraceLog(logLevel: i32, text: *extern.char, info: ...*extern.char)
fn TraceLog(logLevel: i32, text: str, info: ...str) {
	unsafe {
		let mut arr = make([]*extern.char, 0, len(info))
		for i in info {
			arr = append(arr, strToCharPtr(info[i]))
		}
		extern.TraceLog(logLevel, strToCharPtr(text), arr...)
	}
}

// RLAPI void SetTraceLogLevel(int logLevel)                        // Set the current threshold (minimum) log level
extern unsafe fn SetTraceLogLevel(logLevel: i32)
fn SetTraceLogLevel(logLevel: i32) {
	unsafe { extern.SetTraceLogLevel(logLevel) }
}

// RLAPI void *MemAlloc(unsigned int size)                          // Internal memory allocator
extern unsafe fn MemAlloc(size: u32)
fn MemAlloc(size: u32) {
	unsafe { extern.MemAlloc(size) }
}

// RLAPI void *MemRealloc(void *ptr, unsigned int size)             // Internal memory reallocator
extern unsafe fn MemRealloc(ptr: *any, size: u32)
fn MemRealloc(ptr: *any, size: u32) {
	unsafe { extern.MemRealloc(ptr, size) }
}

// RLAPI void MemFree(void *ptr)                                    // Internal memory free
extern unsafe fn MemFree(ptr: *any)
fn MemFree(ptr: *any) {
	unsafe { extern.MemFree(ptr) }
}

// Set custom callbacks
// WARNING: Callbacks setup is intended for advanced users
// RLAPI void SetTraceLogCallback(TraceLogCallback callback)         // Set custom trace log
extern unsafe fn SetTraceLogCallback(callback: any)
fn SetTraceLogCallback(callback: any) {
	//todo
}

// RLAPI void SetLoadFileDataCallback(LoadFileDataCallback callback) // Set custom file binary data loader
extern unsafe fn SetLoadFileDataCallback(callback: any)
fn SetLoadFileDataCallback(callback: any) {
	//todo
}

// RLAPI void SetSaveFileDataCallback(SaveFileDataCallback callback) // Set custom file binary data saver
extern unsafe fn SetSaveFileDataCallback(callback: any)
fn SetSaveFileDataCallback(callback: any) {
	//todo
}

// RLAPI void SetLoadFileTextCallback(LoadFileTextCallback callback) // Set custom file text data loader
extern unsafe fn SetLoadFileTextCallback(callback: any)
fn SetLoadFileTextCallback(callback: any) {
	//todo
}

// RLAPI void SetSaveFileTextCallback(SaveFileTextCallback callback) // Set custom file text data saver
extern unsafe fn SetSaveFileTextCallback(callback: any)
fn SetSaveFileTextCallback(callback: any) {
	//todo
}

// Files management functions
// RLAPI unsigned char *LoadFileData(const char *fileName, int *dataSize) // Load file data as byte array (read)
extern unsafe fn LoadFileData(fileName: *extern.char, dataSize: *i32): *u8
fn LoadFileData(fileName: *extern.char, dataSize: []i32): *u8 {
	ret unsafe { extern.LoadFileData(fileName, &dataSize[0]) }
}

// RLAPI void UnloadFileData(unsigned char *data)                   // Unload file data allocated by LoadFileData()
extern unsafe fn UnloadFileData(data: *u8)
fn UnloadFileData(data: []u8) {
	unsafe { extern.UnloadFileData(&data[0]) }
}

// RLAPI bool SaveFileData(const char *fileName, void *data, int dataSize) // Save data to file from byte array (write), returns true on success
extern unsafe fn SaveFileData(fileName: *extern.char, data: *any, dataSize: i32): bool
fn SaveFileData(fileName: str, data: *any, dataSize: i32): bool {
	ret unsafe { extern.SaveFileData(strToCharPtr(fileName), &data[0], dataSize) }
}

// RLAPI bool ExportDataAsCode(const unsigned char *data, int dataSize, const char *fileName) // Export data to code (.h), returns true on success
extern unsafe fn ExportDataAsCode(data: *u8, dataSize: i32, fileName: *extern.char): bool
fn ExportDataAsCode(data: []u8, dataSize: i32, fileName: str): bool {
	ret unsafe { extern.ExportDataAsCode(&data[0], dataSize, strToCharPtr(fileName)) }
}

// RLAPI char *LoadFileText(const char *fileName)                   // Load text data from file (read), returns a '\0' terminated string
extern unsafe fn LoadFileText(fileName: *extern.char): *extern.char
fn LoadFileText(fileName: *extern.char): str {
	let s = unsafe { extern.LoadFileText(fileName) }
	ret unsafe { ptrCharToStr(s) }
}

// RLAPI void UnloadFileText(char *text)                            // Unload file text data allocated by LoadFileText()
extern unsafe fn UnloadFileText(text: *extern.char)
fn UnloadFileText(text: str) {
	unsafe { extern.UnloadFileText(strToCharPtr(text)) }
}

// RLAPI bool SaveFileText(const char *fileName, char *text)        // Save text data to file (write), string must be '\0' terminated, returns true on success
extern unsafe fn SaveFileText(fileName: *extern.char, text: *extern.char): bool
fn SaveFileText(fileName: str, text: str): bool {
	ret unsafe { extern.SaveFileText(strToCharPtr(fileName), strToCharPtr(text)) }
}

// Input-related functions: keyboard
// RLAPI bool IsKeyPressed(int key);                             // Check if a key has been pressed once
extern unsafe fn IsKeyPressed(key: int): bool
fn IsKeyPressed(key: int): bool {
	ret unsafe { extern.IsKeyPressed(key) }
}

// RLAPI bool IsKeyPressedRepeat(int key);                       // Check if a key has been pressed again
extern unsafe fn IsKeyPressedRepeat(key: int): bool
fn IsKeyPressedRepeat(key: int): bool {
	ret unsafe { extern.IsKeyPressedRepeat(key) }
}

// RLAPI bool IsKeyDown(int key);                                // Check if a key is being pressed
extern unsafe fn IsKeyDown(key: int): bool
fn IsKeyDown(key: int): bool {
	ret unsafe { extern.IsKeyDown(key) }
}

// RLAPI bool IsKeyReleased(int key);                            // Check if a key has been released once
extern unsafe fn IsKeyReleased(key: int): bool
fn IsKeyReleased(key: int): bool {
	ret unsafe { extern.IsKeyReleased(key) }
}

// RLAPI bool IsKeyUp(int key);                                  // Check if a key is NOT being pressed
extern unsafe fn IsKeyUp(key: int): bool
fn IsKeyUp(key: int): bool {
	ret unsafe { extern.IsKeyUp(key) }
}

// RLAPI int GetKeyPressed(void);                                // Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
extern unsafe fn GetKeyPressed(): int
fn GetKeyPressed(): int {
	ret unsafe { extern.GetKeyPressed() }
}

// RLAPI int GetCharPressed(void);                               // Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
extern unsafe fn GetCharPressed(): int
fn GetCharPressed(): int {
	ret unsafe { extern.GetCharPressed() }
}

// RLAPI void SetExitKey(int key);                               // Set a custom key to exit program (default is ESC)
extern unsafe fn SetExitKey(key: int)
fn SetExitKey(key: int) {
	unsafe { extern.SetExitKey(key) }
}

// Input-related functions: gamepads
// RLAPI bool IsGamepadAvailable(int gamepad);                                        // Check if a gamepad is available
extern unsafe fn IsGamepadAvailable(gamepad: int): bool
fn IsGamepadAvailable(gamepad: int): bool {
	ret unsafe { extern.IsGamepadAvailable(gamepad) }
}

//TODO: update later
// RLAPI const char *GetGamepadName(int gamepad);                                     // Get gamepad internal name id
//extern unsafe fn GetGamepadName(gamepad: int): *extern.char
//fn GetGamepadName(gamepad: int): str {
//	let name = unsafe { extern.GetGamepadName(gamepad) }
//	ret unsafe { ptrCharToStr(name) }
//}

// RLAPI bool IsGamepadButtonPressed(int gamepad, int button);                        // Check if a gamepad button has been pressed once
extern unsafe fn IsGamepadButtonPressed(gamepad: int, button: int): bool
fn IsGamepadButtonPressed(gamepad: int, button: int): bool {
	ret unsafe { extern.IsGamepadButtonPressed(gamepad, button) }
}

// RLAPI bool IsGamepadButtonDown(int gamepad, int button);                           // Check if a gamepad button is being pressed
extern unsafe fn IsGamepadButtonDown(gamepad: int, button: int): bool
fn IsGamepadButtonDown(gamepad: int, button: int): bool {
	ret unsafe { extern.IsGamepadButtonDown(gamepad, button) }
}

// RLAPI bool IsGamepadButtonReleased(int gamepad, int button);                       // Check if a gamepad button has been released once
extern unsafe fn IsGamepadButtonReleased(gamepad: int, button: int): bool
fn IsGamepadButtonReleased(gamepad: int, button: int): bool {
	ret unsafe { extern.IsGamepadButtonReleased(gamepad, button) }
}

// RLAPI bool IsGamepadButtonUp(int gamepad, int button);                             // Check if a gamepad button is NOT being pressed
extern unsafe fn IsGamepadButtonUp(gamepad: int, button: int): bool
fn IsGamepadButtonUp(gamepad: int, button: int): bool {
	ret unsafe { extern.IsGamepadButtonUp(gamepad, button) }
}

// RLAPI int GetGamepadButtonPressed(void);                                           // Get the last gamepad button pressed
extern unsafe fn GetGamepadButtonPressed(): int
fn GetGamepadButtonPressed(): int {
	ret unsafe { extern.GetGamepadButtonPressed() }
}

// RLAPI int GetGamepadAxisCount(int gamepad);                                        // Get gamepad axis count for a gamepad
extern unsafe fn GetGamepadAxisCount(gamepad: int): int
fn GetGamepadAxisCount(gamepad: int): int {
	ret unsafe { extern.GetGamepadAxisCount(gamepad) }
}

// RLAPI float GetGamepadAxisMovement(int gamepad, int axis);                         // Get axis movement value for a gamepad axis
extern unsafe fn GetGamepadAxisMovement(gamepad: int, axis: int): f32
fn GetGamepadAxisMovement(gamepad: int, axis: int): f32 {
	ret unsafe { extern.GetGamepadAxisMovement(gamepad, axis) }
}

// RLAPI int SetGamepadMappings(const char *mappings);                                // Set internal gamepad mappings (SDL_GameControllerDB)
extern unsafe fn SetGamepadMappings(mappings: *extern.char): int
fn SetGamepadMappings(mappings: str): int {
	ret unsafe { extern.SetGamepadMappings(strToCharPtr(mappings)) }
}

// RLAPI void SetGamepadVibration(int gamepad, float leftMotor, float rightMotor, float duration); // Set gamepad vibration for both motors (duration in seconds)
extern unsafe fn SetGamepadVibration(gamepad: int, leftMotor: f32, rightMotor: f32, duration: f32)
fn SetGamepadVibration(gamepad: int, leftMotor: f32, rightMotor: f32, duration: f32) {
	unsafe { extern.SetGamepadVibration(gamepad, leftMotor, rightMotor, duration) }
}

//*****************************************MOUSE***************************************************
// RLAPI bool IsMouseButtonPressed(int button);                  // Check if a mouse button has been pressed once
extern unsafe fn IsMouseButtonPressed(button: int): bool
fn IsMouseButtonPressed(button: MouseButton): bool {
    ret unsafe { extern.IsMouseButtonPressed(int(button)) }
}

// RLAPI bool IsMouseButtonDown(int button);                     // Check if a mouse button is being pressed
extern unsafe fn IsMouseButtonDown(button: int): bool
fn IsMouseButtonDown(button: MouseButton): bool {
    ret unsafe { extern.IsMouseButtonDown(int(button)) }
}

// RLAPI bool IsMouseButtonReleased(int button);                 // Check if a mouse button has been released once
extern unsafe fn IsMouseButtonReleased(button: int): bool
fn IsMouseButtonReleased(button: MouseButton): bool {
    ret unsafe { extern.IsMouseButtonReleased(int(button)) }
}

// RLAPI bool IsMouseButtonUp(int button);                       // Check if a mouse button is NOT being pressed
extern unsafe fn IsMouseButtonUp(button: int): bool
fn IsMouseButtonUp(button: MouseButton): bool {
    ret unsafe { extern.IsMouseButtonUp(int(button)) }
}

// RLAPI int GetMouseX(void);                                    // Get mouse position X
extern unsafe fn GetMouseX(): int
fn GetMouseX(): int {
    ret unsafe { extern.GetMouseX() }
}

// RLAPI int GetMouseY(void);                                    // Get mouse position Y
extern unsafe fn GetMouseY(): int
fn GetMouseY(): int {
    ret unsafe { extern.GetMouseY() }
}

// RLAPI Vector2 GetMousePosition(void);                         // Get mouse position XY
extern unsafe fn GetMousePosition(): Vector2
fn GetMousePosition(): Vector2 {
    ret unsafe { extern.GetMousePosition() }
}

// RLAPI Vector2 GetMouseDelta(void);                            // Get mouse delta between frames
extern unsafe fn GetMouseDelta(): Vector2
fn GetMouseDelta(): Vector2 {
    ret unsafe { extern.GetMouseDelta() }
}

// RLAPI void SetMousePosition(int x, int y);                    // Set mouse position XY
extern unsafe fn SetMousePosition(x: int, y: int)
fn SetMousePosition(x: int, y: int) {
    unsafe { extern.SetMousePosition(x, y) }
}

// RLAPI void SetMouseOffset(int offsetX, int offsetY);          // Set mouse offset
extern unsafe fn SetMouseOffset(offsetX: int, offsetY: int)
fn SetMouseOffset(offsetX: int, offsetY: int) {
    unsafe { extern.SetMouseOffset(offsetX, offsetY) }
}

// RLAPI void SetMouseScale(float scaleX, float scaleY);         // Set mouse scaling
extern unsafe fn SetMouseScale(scaleX: f32, scaleY: f32)
fn SetMouseScale(scaleX: f32, scaleY: f32) {
    unsafe { extern.SetMouseScale(scaleX, scaleY) }
}

// RLAPI float GetMouseWheelMove(void);                          // Get mouse wheel movement for X or Y, whichever is larger
extern unsafe fn GetMouseWheelMove(): f32
fn GetMouseWheelMove(): f32 {
    ret unsafe { extern.GetMouseWheelMove() }
}

// RLAPI Vector2 GetMouseWheelMoveV(void);                       // Get mouse wheel movement for both X and Y
extern unsafe fn GetMouseWheelMoveV(): Vector2
fn GetMouseWheelMoveV(): Vector2 {
   ret unsafe { extern.GetMouseWheelMoveV() }
}

// RLAPI void SetMouseCursor(int cursor);                        // Set mouse cursor
extern unsafe fn SetMouseCursor(cursor: int)
fn SetMouseCursor(cursor: MouseCursor){
   unsafe { extern.SetMouseCursor(int(cursor)) }
}

//*********************************************************
// Camera System Functions
// RLAPI void UpdateCamera(Camera *camera, int mode); 
extern unsafe fn UpdateCamera(camera: *Camera, mode: CameraMode)
fn UpdateCamera(camera: *Camera, mode: CameraMode){
   unsafe { extern.UpdateCamera(camera, mode) }
}

//RLAPI void UpdateCameraPro(Camera *camera, Vector3 movement, Vector3 rotation, float zoom);
extern unsafe fn UpdateCameraPro(camera: *Camera, movement: Vector3, rotation: Vector3, zoom: f32)
fn UpdateCameraPro(camera: *Camera, movement: Vector3, rotation: Vector3, zoom: f32){
   unsafe { extern.UpdateCameraPro(camera, movement, rotation, zoom) }
}

//***************************************************************************************
// Drawing-related functions

extern unsafe fn ClearBackground(color: extern.Color)
fn ClearBackground(color: Color) {
	unsafe { extern.ClearBackground(color) }
}

extern unsafe fn BeginDrawing()
fn BeginDrawing() {
	unsafe { extern.BeginDrawing() }
}

extern unsafe fn EndDrawing()
fn EndDrawing() {
	unsafe { extern.EndDrawing() }
}

// RLAPI void BeginMode2D(Camera2D camera);                          // Begin 2D mode with custom camera (2D)
// RLAPI void EndMode2D(void);                                       // Ends 2D mode with custom camera
extern unsafe fn EndMode2D()
fn EndMode2D() {
	unsafe { extern.EndMode2D() }
}

// RLAPI void BeginMode3D(Camera3D camera);                          // Begin 3D mode with custom camera (3D)
extern unsafe fn BeginMode3D(camera: Camera3D)
fn BeginMode3D(camera: Camera3D) {
	unsafe { extern.BeginMode3D(camera) }
}

// RLAPI void EndMode3D(void);                                       // Ends 3D mode and returns to default 2D orthographic mode
extern unsafe fn EndMode3D()
fn EndMode3D() {
	unsafe { extern.EndMode3D() }
}

// RLAPI void BeginTextureMode(RenderTexture2D target);              // Begin drawing to render texture
extern unsafe fn BeginTextureMode(target: RenderTexture2D)
fn BeginTextureMode(target: RenderTexture2D) {
	unsafe {
		extern.BeginTextureMode(target)
	}
}

// RLAPI void EndTextureMode(void);                                  // Ends drawing to render texture
extern unsafe fn EndTextureMode()
fn EndTextureMode() {
	unsafe { extern.EndTextureMode() }
}

// RLAPI void BeginShaderMode(Shader shader);                        // Begin custom shader drawing
extern unsafe fn BeginShaderMode(shader: Shader)
fn BeginShaderMode(shader: Shader) {
	unsafe { extern.BeginShaderMode(shader) }
}

// RLAPI void EndShaderMode(void);                                   // End custom shader drawing (use default shader)
extern unsafe fn EndShaderMode()
fn EndShaderMode() {
	unsafe { extern.EndShaderMode() }
}

// RLAPI void BeginBlendMode(int mode);                              // Begin blending mode (alpha, additive, multiplied, subtract, custom)
extern unsafe fn BeginBlendMode(mode: i32)
fn BeginBlendMode(mode: i32) {
	unsafe { extern.BeginBlendMode(mode) }
}

// RLAPI void EndBlendMode(void);                                    // End blending mode (reset to default: alpha blending)
extern unsafe fn EndBlendMode()
fn EndBlendMode() {
	unsafe { extern.EndBlendMode() }
}

// RLAPI void BeginScissorMode(int x, int y, int width, int height); // Begin scissor mode (define screen area for following drawing)
extern unsafe fn BeginScissorMode(x: i32, y: i32, w: i32, h: i32)
fn BeginScissorMode(x: i32, y: i32, w: i32, h: i32) {
	unsafe { extern.BeginScissorMode(x, y, w, h) }
}

// RLAPI void EndScissorMode(void);                                  // End scissor mode
extern unsafe fn EndScissorMode()
fn EndScissorMode() {
	unsafe { extern.EndScissorMode() }
}

// RLAPI void BeginVrStereoMode(VrStereoConfig config);              // Begin stereo rendering (requires VR simulator)
extern unsafe fn BeginVrStereoMode(config: VrStereoConfig)
fn BeginVrStereoMode(config: VrStereoConfig) {
	unsafe { extern.BeginVrStereoMode(config) }
}

// RLAPI void EndVrStereoMode(void);                                 // End stereo rendering (requires VR simulator)
extern unsafe fn EndVrStereoMode()
fn EndVrStereoMode() {
	unsafe { extern.EndVrStereoMode() }
}

// Shader management functions
// NOTE: Shader functionality is not available on OpenGL 1.1
// RLAPI Shader LoadShader(const char *vsFileName, const char *fsFileName);   // Load shader from files and bind default locations
extern unsafe fn LoadShader(vsFileName: *extern.char, fsFileName: *extern.char): Shader
fn LoadShader(vsFileName: str, fsFileName: str): Shader {
	ret unsafe { extern.LoadShader(strToCharPtr(vsFileName), strToCharPtr(fsFileName)) }
}

// RLAPI Shader LoadShaderFromMemory(const char *vsCode, const char *fsCode); // Load shader from code strings and bind default locations
extern unsafe fn LoadShaderFromMemory(vsCode: *extern.char, fsCode: *extern.char): Shader
fn LoadShaderFromMemory(vsCode: str, fsCode: str): Shader {
	ret unsafe { extern.LoadShaderFromMemory(strToCharPtr(vsCode), strToCharPtr(fsCode)) }
}

// RLAPI bool IsShaderValid(Shader shader);                                   // Check if a shader is valid (loaded on GPU)
extern unsafe fn IsShaderValid(shader: Shader): bool
fn IsShaderValid(shader: Shader): bool {
	ret unsafe { extern.IsShaderValid(shader) }
}

// RLAPI int GetShaderLocation(Shader shader, const char *uniformName);       // Get shader uniform location
extern unsafe fn GetShaderLocation(shader: Shader, uniformName: *extern.char): i32
fn GetShaderLocation(shader: Shader, uniformName: str): i32 {
	ret unsafe { extern.GetShaderLocation(shader, strToCharPtr(uniformName)) }
}

// RLAPI int GetShaderLocationAttrib(Shader shader, const char *attribName);  // Get shader attribute location
extern unsafe fn GetShaderLocationAttrib(shader: Shader, attribName: *extern.char): i32
fn GetShaderLocationAttrib(shader: Shader, attribName: str): i32 {
	ret unsafe { extern.GetShaderLocationAttrib(shader, strToCharPtr(attribName)) }
}

//TODO: review later
// RLAPI void SetShaderValue(Shader shader, int locIndex, const void *value, int uniformType);               // Set shader uniform value
extern unsafe fn SetShaderValue(shader: Shader, locIndex: i32, value: extern.Void, uniformType: i32)
fn SetShaderValue(shader: Shader, locIndex: i32, value: extern.Void, uniformType: i32) {
	unsafe { extern.SetShaderValue(shader, locIndex, value, uniformType) }
}

//TODO: review later
// RLAPI void SetShaderValueV(Shader shader, int locIndex, const void *value, int uniformType, int count);   // Set shader uniform value vector
extern unsafe fn SetShaderValueV(shader: Shader, locIndex: i32, value: extern.Void, uniformType: i32, count: i32)
fn SetShaderValueV(shader: Shader, locIndex: i32, value: extern.Void, uniformType: i32, count: i32) {
	unsafe { extern.SetShaderValueV(shader, locIndex, value, uniformType, count) }
}

// RLAPI void SetShaderValueMatrix(Shader shader, int locIndex, Matrix mat);         // Set shader uniform value (matrix 4x4)
extern unsafe fn SetShaderValueMatrix(shader: Shader, locIndex: i32, mat: Matrix)
fn SetShaderValueMatrix(shader: Shader, locIndex: i32, mat: Matrix) {
	unsafe { extern.SetShaderValueMatrix(shader, locIndex, mat) }
}

// RLAPI void SetShaderValueTexture(Shader shader, int locIndex, Texture2D texture); // Set shader uniform value for texture (sampler2d)
extern unsafe fn SetShaderValueTexture(shader: Shader, locIndex: i32, texture: Texture2D)
fn SetShaderValueTexture(shader: Shader, locIndex: i32, texture: Texture2D) {
	unsafe { extern.SetShaderValueTexture(shader, locIndex, texture) }
}

// RLAPI void UnloadShader(Shader shader);
extern unsafe fn UnloadShader(shader: Shader)
fn UnloadShader(shader: Shader) {
	unsafe { extern.UnloadShader(shader) }
}

// *************************************************************************************************
// Basic shapes drawing functions
// RLAPI void DrawPixel(int posX, int posY, Color color);                                                   // Draw a pixel using geometry [Can be slow, use with care]
extern unsafe fn DrawPixel(posX: i32, posY: i32, color: Color)
fn DrawPixel(posX: i32, posY: i32, color: Color) {
	unsafe { extern.DrawPixel(posX, posY, color) }
}

// RLAPI void DrawPixelV(Vector2 position, Color color);                                                    // Draw a pixel using geometry (Vector version) [Can be slow, use with care]
extern unsafe fn DrawPixelV(position: Vector2, color: Color)
fn DrawPixelV(position: Vector2, color: Color) {
	unsafe { extern.DrawPixelV(position, color) }
}

// RLAPI void DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, Color color);                // Draw a line
extern unsafe fn DrawLine(startX: i32, startY: i32, endPosX: i32, endPosY: i32, color: Color)
fn DrawLine(startX: i32, startY: i32, endX: i32, endY: i32, color: Color) {
	unsafe { extern.DrawLine(startX, startY, endX, endY, color) }
}

// RLAPI void DrawLineV(Vector2 startPos, Vector2 endPos, Color color);                                     // Draw a line (using gl lines)
extern unsafe fn DrawLineV(start: Vector2, end: Vector2, color: Color)
fn DrawLineV(start: Vector2, end: Vector2, color: Color) {
	unsafe { extern.DrawLineV(start, end, color) }
}

// RLAPI void DrawLineEx(Vector2 startPos, Vector2 endPos, float thick, Color color);                       // Draw a line (using triangles/quads)
extern unsafe fn DrawLineEx(start: Vector2, end: Vector2, thick: f32, color: Color)
fn DrawLineEx(start: Vector2, end: Vector2, thick: f32, color: Color) {
	unsafe { extern.DrawLineEx(start, end, thick, color) }
}

// RLAPI void DrawLineStrip(const Vector2 *points, int pointCount, Color color);                            // Draw lines sequence (using gl lines)
extern unsafe fn DrawLineStrip(points: *Vector2, pointCount: i32, color: Color)
fn DrawLineStrip(points: []Vector2, pointCount: i32, color: Color) {
	unsafe { extern.DrawLineStrip(&points[0], pointCount, color) }
}

// RLAPI void DrawLineBezier(Vector2 startPos, Vector2 endPos, float thick, Color color);                   // Draw line segment cubic-bezier in-out interpolation
extern unsafe fn DrawLineBezier(start: Vector2, end: Vector2, thick: f32, color: Color)
fn DrawLineBezier(start: Vector2, end: Vector2, thick: f32, color: Color) {
	unsafe { extern.DrawLineBezier(start, end, thick, color) }
}

// RLAPI void DrawCircle(int centerX, int centerY, float radius, Color color);                              // Draw a color-filled circle
extern unsafe fn DrawCircle(x: i32, y: i32, radius: f32, color: Color)
fn DrawCircle(x: i32, y: i32, radius: f32, color: Color) {
	unsafe { extern.DrawCircle(x, y, radius, color) }
}

// RLAPI void DrawCircleSectorLines(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color); // Draw circle sector outline
extern unsafe fn DrawCircleSectorLines(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color)
fn DrawCircleSectorLines(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color) {
	unsafe { extern.DrawCircleSectorLines(center, radius, startAngle, endAngle, segments, color) }
}

// RLAPI void DrawCircleGradient(int centerX, int centerY, float radius, Color inner, Color outer);         // Draw a gradient-filled circle
extern unsafe fn DrawCircleGradient(x: i32, y: i32, radius: f32, inner: Color, color: Color)
fn DrawCircleGradient(x: i32, y: i32, radius: f32, inner: Color, color: Color) {
	unsafe { extern.DrawCircleGradient(x, y, radius, inner, color) }
}

// RLAPI void DrawCircleV(Vector2 center, float radius, Color color);                                       // Draw a color-filled circle (Vector version)
extern unsafe fn DrawCircleV(center: Vector2, radius: f32, color: Color)
fn DrawCircleV(center: Vector2, radius: f32, color: Color) {
	unsafe { extern.DrawCircleV(center, radius, color) }
}

// RLAPI void DrawCircleLines(int centerX, int centerY, float radius, Color color);                         // Draw circle outline
extern unsafe fn DrawCircleLines(x: i32, y: i32, radius: f32, color: Color)
fn DrawCircleLines(x: i32, y: i32, radius: f32, color: Color) {
	unsafe { extern.DrawCircleLines(x, y, radius, color) }
}

// RLAPI void DrawCircleLinesV(Vector2 center, float radius, Color color);                                  // Draw circle outline (Vector version)
extern unsafe fn DrawCircleLinesV(center: Vector2, radius: f32, color: Color)
fn DrawCircleLinesV(center: Vector2, radius: f32, color: Color) {
	unsafe { extern.DrawCircleLinesV(center, radius, color) }
}

// RLAPI void DrawEllipse(int centerX, int centerY, float radiusH, float radiusV, Color color);             // Draw ellipse
extern unsafe fn DrawEllipse(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color)
fn DrawEllipse(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color) {
	unsafe { extern.DrawEllipse(centerX, centerY, radiusH, radiusV, color) }
}

// RLAPI void DrawEllipseLines(int centerX, int centerY, float radiusH, float radiusV, Color color);        // Draw ellipse outline
extern unsafe fn DrawEllipseLines(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color)
fn DrawEllipseLines(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color) {
	unsafe { extern.DrawEllipseLines(centerX, centerY, radiusH, radiusV, color) }
}

// RLAPI void DrawRing(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color); // Draw ring
extern unsafe fn DrawRing(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color)
fn DrawRing(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color) {
	unsafe { extern.DrawRing(center, innerRadius, outerRadius, startAngle, endAngle, segments, color) }
}

// RLAPI void DrawRingLines(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color);    // Draw ring outline
extern unsafe fn DrawRingLines(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color)
fn DrawRingLines(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color) {
	unsafe { extern.DrawRingLines(center, innerRadius, outerRadius, startAngle, endAngle, segments, color) }
}

// RLAPI void DrawRectangle(int posX, int posY, int width, int height, Color color);                        // Draw a color-filled rectangle
extern unsafe fn DrawRectangle(posX: int, posY: int, width: int, height: int, color: Color)
fn DrawRectangle(posX: int, posY: int, width: int, height: int, color: Color) {
	unsafe { extern.DrawRectangle(posX, posY, width, height, color) }
}

// RLAPI void DrawRectangleV(Vector2 position, Vector2 size, Color color);                                  // Draw a color-filled rectangle (Vector version)
extern unsafe fn DrawRectangleV(position: Vector2, size: Vector2, color: Color)
fn DrawRectangleV(position: Vector2, size: Vector2, color: Color) {
	unsafe { extern.DrawRectangleV(position, size, color) }
}

// RLAPI void DrawRectangleRec(Rectangle rec, Color color);                                                 // Draw a color-filled rectangle
extern unsafe fn DrawRectangleRec(rec: Rectangle, color: Color)
fn DrawRectangleRec(rec: Rectangle, color: Color) {
	unsafe { extern.DrawRectangleRec(rec, color) }
}

// RLAPI void DrawRectanglePro(Rectangle rec, Vector2 origin, float rotation, Color color);                 // Draw a color-filled rectangle with pro parameters
extern unsafe fn DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: f32, color: Color)
fn DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: f32, color: Color) {
	unsafe { extern.DrawRectanglePro(rec, origin, rotation, color) }
}

// RLAPI void DrawRectangleGradientV(int posX, int posY, int width, int height, Color top, Color bottom);   // Draw a vertical-gradient-filled rectangle
extern unsafe fn DrawRectangleGradientV(posX: i32, posY: i32, width: i32, height: i32, top: Color, bottom: Color)
fn DrawRectangleGradientV(posX: i32, posY: i32, width: i32, height: i32, top: Color, bottom: Color) {
	unsafe { extern.DrawRectangleGradientV(posX, posY, width, height, top, bottom) }
}

// RLAPI void DrawRectangleGradientH(int posX, int posY, int width, int height, Color left, Color right);   // Draw a horizontal-gradient-filled rectangle
extern unsafe fn DrawRectangleGradientH(posX: i32, posY: i32, width: i32, height: i32, left: Color, right: Color)
fn DrawRectangleGradientH(posX: i32, posY: i32, width: i32, height: i32, left: Color, right: Color) {
	unsafe { extern.DrawRectangleGradientH(posX, posY, width, height, left, right) }
}

// RLAPI void DrawRectangleGradientEx(Rectangle rec, Color topLeft, Color bottomLeft, Color topRight, Color bottomRight); // Draw a gradient-filled rectangle with custom vertex colors
extern unsafe fn DrawRectangleGradientEx(rec: Rectangle, topLeft: Color, bottomLeft: Color, topRight: Color, bottomRight: Color)
fn DrawRectangleGradientEx(rec: Rectangle, topLeft: Color, bottomLeft: Color, topRight: Color, bottomRight: Color) {
	unsafe { extern.DrawRectangleGradientEx(rec, topLeft, bottomLeft, topRight, bottomRight) }
}

// RLAPI void DrawRectangleLines(int posX, int posY, int width, int height, Color color);                   // Draw rectangle outline
extern unsafe fn DrawRectangleLines(posX: int, posY: int, width: int, height: int, color: Color)
fn DrawRectangleLines(posX: int, posY: int, width: int, height: int, color: Color) {
	unsafe { extern.DrawRectangleLines(posX, posY, width, height, color) }
}

// RLAPI void DrawRectangleLinesEx(Rectangle rec, float lineThick, Color color);                            // Draw rectangle outline with extended parameters
extern unsafe fn DrawRectangleLinesEx(rec: Rectangle, lineThick: f32, color: Color)
fn DrawRectangleLinesEx(rec: Rectangle, lineThick: f32, color: Color) {
	unsafe { extern.DrawRectangleLinesEx(rec, lineThick, color) }
}

// RLAPI void DrawRectangleRounded(Rectangle rec, float roundness, int segments, Color color);              // Draw rectangle with rounded edges
extern unsafe fn DrawRectangleRounded(rec: Rectangle, roundness: f32, segments: i32, color: Color)
fn DrawRectangleRounded(rec: Rectangle, roundness: f32, segments: i32, color: Color) {
	unsafe { extern.DrawRectangleRounded(rec, roundness, segments, color) }
}

// RLAPI void DrawRectangleRoundedLines(Rectangle rec, float roundness, int segments, Color color);         // Draw rectangle lines with rounded edges
extern unsafe fn DrawRectangleRoundedLines(rec: Rectangle, roundness: f32, segments: i32, color: Color)
fn DrawRectangleRoundedLines(rec: Rectangle, roundness: f32, segments: i32, color: Color) {
	unsafe { extern.DrawRectangleRoundedLines(rec, roundness, segments, color) }
}

// RLAPI void DrawRectangleRoundedLinesEx(Rectangle rec, float roundness, int segments, float lineThick, Color color); // Draw rectangle with rounded edges outline
extern unsafe fn DrawRectangleRoundedLinesEx(rec: Rectangle, roundness: f32, segments: i32, lineThick: f32, color: Color)
fn DrawRectangleRoundedLinesEx(rec: Rectangle, roundness: f32, segments: i32, lineThick: f32, color: Color) {
	unsafe { extern.DrawRectangleRoundedLinesEx(rec, roundness, segments, lineThick, color) }
}

// RLAPI void DrawTriangle(Vector2 v1, Vector2 v2, Vector2 v3, Color color);                                // Draw a color-filled triangle (vertex in counter-clockwise order!)
extern unsafe fn DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)
fn DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color) {
	unsafe { extern.DrawTriangle(v1, v2, v3, color) }
}

// RLAPI void DrawTriangleLines(Vector2 v1, Vector2 v2, Vector2 v3, Color color);                           // Draw triangle outline (vertex in counter-clockwise order!)
extern unsafe fn DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)
fn DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color) {
	unsafe { extern.DrawTriangleLines(v1, v2, v3, color) }
}

// RLAPI void DrawTriangleFan(const Vector2 *points, int pointCount, Color color);                          // Draw a triangle fan defined by points (first vertex is the center)
extern unsafe fn DrawTriangleFan(points: *Vector2, pointCount: i32, color: Color)
fn DrawTriangleFan(points: []Vector2, pointCount: i32, color: Color) {
	unsafe { extern.DrawTriangleFan(&points[0], pointCount, color) }
}

// RLAPI void DrawTriangleStrip(const Vector2 *points, int pointCount, Color color);                        // Draw a triangle strip defined by points
extern unsafe fn DrawTriangleStrip(points: *Vector2, pointCount: i32, color: Color)
fn DrawTriangleStrip(points: []Vector2, pointCount: i32, color: Color) {
	unsafe { extern.DrawTriangleStrip(&points[0], pointCount, color) }
}

// RLAPI void DrawPoly(Vector2 center, int sides, float radius, float rotation, Color color);               // Draw a regular polygon (Vector version)
extern unsafe fn DrawPoly(center: Vector2, sides: i32, radius: f32, rotation: f32, color: Color)
fn DrawPoly(center: Vector2, sides: i32, radius: f32, rotation: f32, color: Color) {
	unsafe { extern.DrawPoly(center, sides, radius, rotation, color) }
}

// RLAPI void DrawPolyLines(Vector2 center, int sides, float radius, float rotation, Color color);          // Draw a polygon outline of n sides
extern unsafe fn DrawPolyLines(center: Vector2, sides: i32, radius: f32, rotation: f32, color: Color)
fn DrawPolyLines(center: Vector2, sides: i32, radius: f32, rotation: f32, color: Color) {
	unsafe { extern.DrawPolyLines(center, sides, radius, rotation, color) }
}

// RLAPI void DrawPolyLinesEx(Vector2 center, int sides, float radius, float rotation, float lineThick, Color color); // Draw a polygon outline of n sides with extended parameters
extern unsafe fn DrawPolyLinesEx(center: Vector2, sides: i32, radius: f32, rotation: f32, lineThick: f32, color: Color)
fn DrawPolyLinesEx(center: Vector2, sides: i32, radius: f32, rotation: f32, lineThick: f32, color: Color) {
	unsafe { extern.DrawPolyLinesEx(center, sides, radius, rotation, lineThick, color) }
}

//**********************************************************************************************

// RLAPI void DrawFPS(int posX, int posY);                                                     // Draw current FPS
extern unsafe fn DrawFPS(posX: i32, posY: i32)
fn DrawFPS(posX: i32, posY: i32) {
	unsafe { extern.DrawFPS(posX, posY) }
}

// RLAPI void DrawText(const char *text, int posX, int posY, int fontSize, Color color);       // Draw text (using default font)
extern unsafe fn DrawText(text: *extern.char, posX: int, posY: int, fontSize: i32, color: Color)
fn DrawText(text: str, posX: int, posY: int, fontSize: i32, color: Color) {
	unsafe { extern.DrawText(strToCharPtr(text), posX, posY, fontSize, color) }
}

// RLAPI void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint); // Draw text using font and additional parameters
extern unsafe fn DrawTextEx(font: Font, text: *extern.char, position: Vector2, fontSize: f32, spacing: f32, tint: Color)
fn DrawTextEx(font: Font, text: str, position: Vector2, fontSize: f32, spacing: f32, tint: Color) {
	unsafe { extern.DrawTextEx(font, strToCharPtr(text), position, fontSize, spacing, tint) }
}

// RLAPI void DrawTextPro(Font font, const char *text, Vector2 position, Vector2 origin, float rotation, float fontSize, float spacing, Color tint); // Draw text using Font and pro parameters (rotation)
extern unsafe fn DrawTextPro(font: Font, text: *extern.char, position: Vector2, origin: Vector2, rotation: f32, fontSize: f32, spacing: f32, tint: Color)
fn DrawTextPro(font: Font, text: str, position: Vector2, origin: Vector2, rotation: f32, fontSize: f32, spacing: f32, tint: Color) {
	unsafe { extern.DrawTextPro(font, strToCharPtr(text), position, origin, rotation, fontSize, spacing, tint) }
}

// RLAPI void DrawTextCodepoint(Font font, int codepoint, Vector2 position, float fontSize, Color tint); // Draw one character (codepoint)
extern unsafe fn DrawTextCodepoint(font: Font, codepoint: i32, position: Vector2, fontSize: f32, tint: Color)
fn DrawTextCodepoint(font: Font, codepoint: i32, position: Vector2, fontSize: f32, tint: Color) {
	unsafe { extern.DrawTextCodepoint(font, codepoint, position, fontSize, tint) }
}

// RLAPI void DrawTextCodepoints(Font font, const int *codepoints, int codepointCount, Vector2 position, float fontSize, float spacing, Color tint); // Draw multiple character (codepoint)
extern unsafe fn DrawTextCodepoints(font: Font, codepoints: *i32, codepointCount: i32, position: Vector2, fontSize: f32, spacing: f32, tint: Color)
fn DrawTextCodepoints(font: Font, codepoints: []i32, codepointCount: i32, position: Vector2, fontSize: f32, spacing: f32, tint: Color) {
	unsafe { extern.DrawTextCodepoints(font, &codepoints[0], codepointCount, position, fontSize, spacing, tint) }
}

// RLAPI const char *TextFormat(const char *text, ...);
extern unsafe fn TextFormat(text: *extern.char, info: ...int): str
fn TextFormat(text: str, info: ...int): str {
	unsafe {
		ret extern.TextFormat(strToCharPtr(text), info...)
	}
}

//******************************************************************************************
// Basic geometric 3D shapes drawing functions
// RLAPI void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color);                                    // Draw a line in 3D world space
extern unsafe fn DrawLine3D(startPos: Vector3, endPos: Vector3, color: Color)
fn DrawLine3D(startPos: Vector3, endPos: Vector3, color: Color) {
	unsafe { extern.DrawLine3D(startPos, endPos, color) }
}

// RLAPI void DrawPoint3D(Vector3 position, Color color);                                                   // Draw a point in 3D space, actually a small line
extern unsafe fn DrawPoint3D(position: Vector3, color: Color)
fn DrawPoint3D(position: Vector3, color: Color) {
	unsafe { extern.DrawPoint3D(position, color) }
}

// RLAPI void DrawCircle3D(Vector3 center, float radius, Vector3 rotationAxis, float rotationAngle, Color color); // Draw a circle in 3D world space
extern unsafe fn DrawCircle3D(center: Vector3, radius: f32, rotationAxis: Vector3, rotationAngle: f32, color: Color)
fn DrawCircle3D(center: Vector3, radius: f32, rotationAxis: Vector3, rotationAngle: f32, color: Color) {
	unsafe { extern.DrawCircle3D(center, radius, rotationAxis, rotationAngle, color) }
}

// RLAPI void DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color);                              // Draw a color-filled triangle (vertex in counter-clockwise order!)
extern unsafe fn DrawTriangle3D(v1: Vector3, v2: Vector3, v3: Vector3, color: Color)
fn DrawTriangle3D(v1: Vector3, v2: Vector3, v3: Vector3, color: Color) {
	unsafe { extern.DrawTriangle3D(v1, v2, v3, color) }
}

// RLAPI void DrawTriangleStrip3D(const Vector3 *points, int pointCount, Color color);                      // Draw a triangle strip defined by points
extern unsafe fn DrawTriangleStrip3D(points: *Vector3, pointCount: i32, color: Color)
fn DrawTriangleStrip3D(points: []Vector3, pointCount: i32, color: Color) {
	unsafe { extern.DrawTriangleStrip3D(&points[0], pointCount, color) }
}

// RLAPI void DrawCube(Vector3 position, float width, float height, float length, Color color);             // Draw cube
extern unsafe fn DrawCube(position: Vector3, width: f32, height: f32, length: f32, color: Color)
fn DrawCube(position: Vector3, width: f32, height: f32, length: f32, color: Color) {
	unsafe { extern.DrawCube(position, width, height, length, color) }
}

// RLAPI void DrawCubeV(Vector3 position, Vector3 size, Color color);                                       // Draw cube (Vector version)
extern unsafe fn DrawCubeV(position: Vector3, size: Vector3, color: Color)
fn DrawCubeV(position: Vector3, size: Vector3, color: Color) {
	unsafe { extern.DrawCubeV(position, size, color) }
}

// RLAPI void DrawCubeWires(Vector3 position, float width, float height, float length, Color color);        // Draw cube wires
extern unsafe fn DrawCubeWires(position: Vector3, width: f32, height: f32, length: f32, color: Color)
fn DrawCubeWires(position: Vector3, width: f32, height: f32, length: f32, color: Color) {
	unsafe { extern.DrawCubeWires(position, width, height, length, color) }
}

// RLAPI void DrawCubeWiresV(Vector3 position, Vector3 size, Color color);                                  // Draw cube wires (Vector version)
extern unsafe fn DrawCubeWiresV(position: Vector3, size: Vector3, color: Color)
fn DrawCubeWiresV(position: Vector3, size: Vector3, color: Color) {
	unsafe { extern.DrawCubeWiresV(position, size, color) }
}

// RLAPI void DrawSphere(Vector3 centerPos, float radius, Color color);                                     // Draw sphere
extern unsafe fn DrawSphere(centerPos: Vector3, radius: f32, color: Color)
fn DrawSphere(centerPos: Vector3, radius: f32, color: Color) {
	unsafe { extern.DrawSphere(centerPos, radius, color) }
}

// RLAPI void DrawSphereEx(Vector3 centerPos, float radius, int rings, int slices, Color color);            // Draw sphere with extended parameters
extern unsafe fn DrawSphereEx(centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color)
fn DrawSphereEx(centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color) {
	unsafe { extern.DrawSphereEx(centerPos, radius, rings, slices, color) }
}

// RLAPI void DrawSphereWires(Vector3 centerPos, float radius, int rings, int slices, Color color);         // Draw sphere wires
extern unsafe fn DrawSphereWires(centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color)
fn DrawSphereWires(centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color) {
	unsafe { extern.DrawSphereWires(centerPos, radius, rings, slices, color) }
}

// RLAPI void DrawCylinder(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color); // Draw a cylinder/cone
extern unsafe fn DrawCylinder(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color)
fn DrawCylinder(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color) {
	unsafe { extern.DrawCylinder(position, radiusTop, radiusBottom, height, slices, color) }
}

// RLAPI void DrawCylinderEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color); // Draw a cylinder with base at startPos and top at endPos
extern unsafe fn DrawCylinderEx(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color)
fn DrawCylinderEx(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color) {
	unsafe { extern.DrawCylinderEx(startPos, endPos, startRadius, endRadius, sides, color) }
}

// RLAPI void DrawCylinderWires(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color); // Draw a cylinder/cone wires
extern unsafe fn DrawCylinderWires(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color)
fn DrawCylinderWires(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color) {
	unsafe { extern.DrawCylinderWires(position, radiusTop, radiusBottom, height, slices, color) }
}

// RLAPI void DrawCylinderWiresEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color); // Draw a cylinder wires with base at startPos and top at endPos
extern unsafe fn DrawCylinderWiresEx(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color)
fn DrawCylinderWiresEx(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color) {
	unsafe { extern.DrawCylinderWiresEx(startPos, endPos, startRadius, endRadius, sides, color) }
}

// RLAPI void DrawCapsule(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color); // Draw a capsule with the center of its sphere caps at startPos and endPos
extern unsafe fn DrawCapsule(startPos: Vector3, endPos: Vector3, radius: f32, slices: i32, rings: i32, color: Color)
fn DrawCapsule(startPos: Vector3, endPos: Vector3, radius: f32, slices: i32, rings: i32, color: Color) {
	unsafe { extern.DrawCapsule(startPos, endPos, radius, slices, rings, color) }
}

// RLAPI void DrawCapsuleWires(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color); // Draw capsule wireframe with the center of its sphere caps at startPos and endPos
extern unsafe fn DrawCapsuleWires(startPos: Vector3, endPos: Vector3, radius: f32, slices: i32, rings: i32, color: Color)
fn DrawCapsuleWires(startPos: Vector3, endPos: Vector3, radius: f32, slices: i32, rings: i32, color: Color) {
	unsafe { extern.DrawCapsuleWires(startPos, endPos, radius, slices, rings, color) }
}

// RLAPI void DrawPlane(Vector3 centerPos, Vector2 size, Color color);                                      // Draw a plane XZ
extern unsafe fn DrawPlane(centerPos: Vector3, size: Vector2, color: Color)
fn DrawPlane(centerPos: Vector3, size: Vector2, color: Color) {
	unsafe { extern.DrawPlane(centerPos, size, color) }
}

// RLAPI void DrawRay(Ray ray, Color color);                                                                // Draw a ray line
extern unsafe fn DrawRay(ray: Ray, color: Color)
fn DrawRay(ray: Ray, color: Color) {
	unsafe { extern.DrawRay(ray, color) }
}

// RLAPI void DrawGrid(int slices, float spacing);                                                          // Draw a grid (centered at (0, 0, 0))
extern unsafe fn DrawGrid(slices: i32, spacing: f32)
fn DrawGrid(slices: i32, spacing: f32) {
	unsafe { extern.DrawGrid(slices, spacing) }
}

// Basic shapes collision detection functions
// RLAPI bool CheckCollisionRecs(Rectangle rec1, Rectangle rec2);                                           // Check collision between two rectangles
extern unsafe fn CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle): bool;
fn CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle): bool {
  ret  unsafe { extern.CheckCollisionRecs(rec1, rec2) }
}

// RLAPI bool CheckCollisionCircles(Vector2 center1, float radius1, Vector2 center2, float radius2);        // Check collision between two circles
extern unsafe fn CheckCollisionCircles(center1: Vector2, radius1: f32, center2: Vector2, radius2: f32): bool;
fn CheckCollisionCircles(center1: Vector2, radius1: f32, center2: Vector2, radius2: f32): bool {
  ret  unsafe { extern.CheckCollisionCircles(center1, radius1, center2, radius2) }
}

// RLAPI bool CheckCollisionCircleRec(Vector2 center, float radius, Rectangle rec);                         // Check collision between circle and rectangle
extern unsafe fn CheckCollisionCircleRec(center: Vector2, radius: f32, rec: Rectangle): bool;
fn CheckCollisionCircleRec(center: Vector2, radius: f32, rec: Rectangle): bool {
  ret  unsafe { extern.CheckCollisionCircleRec(center, radius, rec) }
}

// RLAPI bool CheckCollisionCircleLine(Vector2 center, float radius, Vector2 p1, Vector2 p2);               // Check if circle collides with a line created betweeen two points [p1] and [p2]
extern unsafe fn CheckCollisionCircleLine(center: Vector2, radius: f32, p1: Vector2, p2: Vector2): bool;
fn CheckCollisionCircleLine(center: Vector2, radius: f32, p1: Vector2, p2: Vector2): bool {
  ret  unsafe { extern.CheckCollisionCircleLine(center, radius, p1, p2) }
}

// RLAPI bool CheckCollisionPointRec(Vector2 point, Rectangle rec);                                         // Check if point is inside rectangle
extern unsafe fn CheckCollisionPointRec(point: Vector2, rec: Rectangle): bool;
fn CheckCollisionPointRec(point: Vector2, rec: Rectangle): bool {
   ret unsafe { extern.CheckCollisionPointRec(point, rec) }
}

// RLAPI bool CheckCollisionPointCircle(Vector2 point, Vector2 center, float radius);                       // Check if point is inside circle
extern unsafe fn CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: f32): bool;
fn CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: f32): bool {
  ret  unsafe { extern.CheckCollisionPointCircle(point, center, radius) }
}

// RLAPI bool CheckCollisionPointTriangle(Vector2 point, Vector2 p1, Vector2 p2, Vector2 p3);               // Check if point is inside a triangle
extern unsafe fn CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2): bool;
fn CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2): bool {
 ret   unsafe { extern.CheckCollisionPointTriangle(point, p1, p2, p3) }
}

// RLAPI bool CheckCollisionPointLine(Vector2 point, Vector2 p1, Vector2 p2, int threshold);                // Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
extern unsafe fn CheckCollisionPointLine(point: Vector2, p1: Vector2, p2: Vector2, threshold: i32): bool;
fn CheckCollisionPointLine(point: Vector2, p1: Vector2, p2: Vector2, threshold: i32): bool {
  ret  unsafe { extern.CheckCollisionPointLine(point, p1, p2, threshold) }
}

// RLAPI bool CheckCollisionPointPoly(Vector2 point, const Vector2 *points, int pointCount);                // Check if point is within a polygon described by array of vertices
extern unsafe fn CheckCollisionPointPoly(point: Vector2, points: *Vector2, pointCount: i32): bool;
fn CheckCollisionPointPoly(point: Vector2, points: *Vector2, pointCount: i32): bool {
  ret  unsafe { extern.CheckCollisionPointPoly(point, &points[0], pointCount) }
}

// RLAPI bool CheckCollisionLines(Vector2 startPos1, Vector2 endPos1, Vector2 startPos2, Vector2 endPos2, Vector2 *collisionPoint); // Check the collision between two lines defined by two points each, returns collision point by reference
extern unsafe fn CheckCollisionLines(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: *Vector2): bool;
fn CheckCollisionLines(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: *Vector2): bool {
  ret  unsafe { extern.CheckCollisionLines(startPos1, endPos1, startPos2, endPos2, &collisionPoint[0]) }
}

// RLAPI Rectangle GetCollisionRec(Rectangle rec1, Rectangle rec2);                                         // Get collision rectangle for two rectangles collision
extern unsafe fn GetCollisionRec(rec1: Rectangle, rec2: Rectangle): Rectangle;
fn GetCollisionRec(rec1: Rectangle, rec2: Rectangle): Rectangle {
   ret unsafe { extern.GetCollisionRec(rec1, rec2) }
}

// Image loading functions
// NOTE: These functions do not require GPU access
//RLAPI Image LoadImage(const char *fileName);                                                             // Load image from file into CPU memory (RAM)
extern unsafe fn LoadImage(path: *extern.char): Image
fn LoadImage(path: str): Image {
	ret unsafe { extern.LoadImage(strToCharPtr(path)) }
}

//RLAPI Image LoadImageRaw(const char *fileName, int width, int height, int format, int headerSize);       // Load image from RAW file data
extern unsafe fn LoadImageRaw(fileName: *extern.char, width: i32, height: i32, format: i32, headerSize: i32): Image
fn LoadImageRaw(fileName: str, width: i32, height: i32, format: i32, headerSize: i32): Image {
	ret unsafe { extern.LoadImageRaw(strToCharPtr(fileName), width, height, format, headerSize) }
}

//RLAPI Image LoadImageAnim(const char *fileName, int *frames);                                            // Load image sequence from file (frames appended to image.data)
extern unsafe fn LoadImageAnim(fileName: *extern.char, frames: *i32): Image
fn LoadImageAnim(fileName: str, frames: *i32): Image {
	ret unsafe { extern.LoadImageAnim(strToCharPtr(fileName), frames) }
}

//RLAPI Image LoadImageAnimFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int *frames); // Load image sequence from memory buffer
extern unsafe fn LoadImageAnimFromMemory(fileType: *extern.char, fileData: *byte, dataSize: i32, frames: *i32): Image
fn LoadImageAnimFromMemory(fileType: str, fileData: []byte, dataSize: i32, frames: []i32): Image {
	ret unsafe { extern.LoadImageAnimFromMemory(strToCharPtr(fileType), &fileData[0], dataSize, &frames[0]) }
}

//RLAPI Image LoadImageFromMemory(const char *fileType, const unsigned char *fileData, int dataSize);      // Load image from memory buffer, fileType refers to extension: i.e. '.png'
extern unsafe fn LoadImageFromMemory(fileType: *extern.char, fileData: *byte, dataSize: i32): Image
fn LoadImageFromMemory(fileType: str, fileData: []byte, dataSize: i32): Image {
	ret unsafe { extern.LoadImageFromMemory(strToCharPtr(fileType), &fileData[0], dataSize) }
}

//RLAPI Image LoadImageFromTexture(Texture2D texture);                                                     // Load image from GPU texture data
extern unsafe fn LoadImageFromTexture(texture: Texture2D): Image
fn LoadImageFromTexture(texture: Texture2D): Image {
	ret unsafe { extern.LoadImageFromTexture(texture) }
}

//RLAPI Image LoadImageFromScreen(void);                                                                   // Load image from screen buffer and (screenshot)
extern unsafe fn LoadImageFromScreen(): Image
fn LoadImageFromScreen(): Image {
	ret unsafe { extern.LoadImageFromScreen() }
}

//RLAPI bool IsImageValid(Image image);                                                                    // Check if an image is valid (data and parameters)
extern unsafe fn IsImageValid(image: Image): bool
fn IsImageValid(image: Image): bool {
	ret unsafe { extern.IsImageValid(image) }
}

//RLAPI void UnloadImage(Image image);                                                                     // Unload image from CPU memory (RAM)
extern unsafe fn UnloadImage(image: Image)
fn UnloadImage(image: Image) {
	unsafe { extern.UnloadImage(image) }
}

//RLAPI bool ExportImage(Image image, const char *fileName);                                               // Export image data to file, returns true on success
extern unsafe fn ExportImage(image: Image, fileName: *extern.char): bool
fn ExportImage(image: Image, fileName: str): bool {
	ret unsafe { extern.ExportImage(image, strToCharPtr(fileName)) }
}

//RLAPI unsigned char *ExportImageToMemory(Image image, const char *fileType, int *fileSize);              // Export image to memory buffer
extern unsafe fn ExportImageToMemory(image: Image, fileType: *extern.char, fileSize: *i32): *u8
fn ExportImageToMemory(image: Image, fileType: *extern.char, fileSize: []i32): []byte {
	let raw = unsafe { extern.ExportImageToMemory(image, fileType, &fileSize[0]) }
	ret unsafe { ptrU8ToBytes(raw) }
}

//RLAPI bool ExportImageAsCode(Image image, const char *fileName);            // Export image as code file defining an array of bytes, returns true on success
extern unsafe fn ExportImageAsCode(image: Image, fileName: *extern.char): bool
fn ExportImageAsCode(image: Image, fileName: *extern.char): bool {
	ret unsafe { extern.ExportImageAsCode(image, fileName) }
}

//************************************************************************************
// Image generation functions
// RLAPI Image GenImageColor(int width, int height, Color color);                                           // Generate image: plain color
extern unsafe fn GenImageColor(width: i32, height: i32, color: Color): Image
fn GenImageColor(width: i32, height: i32, color: Color): Image {
	ret unsafe { extern.GenImageColor(width, height, color) }
}

// RLAPI Image GenImageGradientLinear(int width, int height, int direction, Color start, Color end);        // Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient
extern unsafe fn GenImageGradientLinear(width: i32, height: i32, direction: i32, start: Color, end: Color): Image
fn GenImageGradientLinear(width: i32, height: i32, direction: i32, start: Color, end: Color): Image {
	ret unsafe { extern.GenImageGradientLinear(width, height, direction, start, end) }
}

// RLAPI Image GenImageGradientRadial(int width, int height, float density, Color inner, Color outer);      // Generate image: radial gradient
extern unsafe fn GenImageGradientRadial(width: i32, height: i32, density: f32, inner: Color, outer: Color): Image
fn GenImageGradientRadial(width: i32, height: i32, density: f32, inner: Color, outer: Color): Image {
	ret unsafe { extern.GenImageGradientRadial(width, height, density, inner, outer) }
}

// RLAPI Image GenImageGradientSquare(int width, int height, float density, Color inner, Color outer);      // Generate image: square gradient
extern unsafe fn GenImageGradientSquare(width: i32, height: i32, density: f32, inner: Color, outer: Color): Image
fn GenImageGradientSquare(width: i32, height: i32, density: f32, inner: Color, outer: Color): Image {
	ret unsafe { extern.GenImageGradientSquare(width, height, density, inner, outer) }
}

// RLAPI Image GenImageChecked(int width, int height, int checksX, int checksY, Color col1, Color col2);    // Generate image: checked
extern unsafe fn GenImageChecked(width: i32, height: i32, checksX: i32, checksY: i32, col1: Color, col2: Color): Image
fn GenImageChecked(width: i32, height: i32, checksX: i32, checksY: i32, col1: Color, col2: Color): Image {
	ret unsafe { extern.GenImageChecked(width, height, checksX, checksY, col1, col2) }
}

// RLAPI Image GenImageWhiteNoise(int width, int height, float factor);                                     // Generate image: white noise
extern unsafe fn GenImageWhiteNoise(width: i32, height: i32, factor: f32): Image
fn GenImageWhiteNoise(width: i32, height: i32, factor: f32): Image {
	ret unsafe { extern.GenImageWhiteNoise(width, height, factor) }
}

// RLAPI Image GenImagePerlinNoise(int width, int height, int offsetX, int offsetY, float scale);           // Generate image: perlin noise
extern unsafe fn GenImagePerlinNoise(width: i32, height: i32, offsetX: i32, offsetY: i32, scale: f32): Image
fn GenImagePerlinNoise(width: i32, height: i32, offsetX: i32, offsetY: i32, scale: f32): Image {
	ret unsafe { extern.GenImagePerlinNoise(width, height, offsetX, offsetY, scale) }
}

// RLAPI Image GenImageCellular(int width, int height, int tileSize);                                       // Generate image: cellular algorithm, bigger tileSize means bigger cells
extern unsafe fn GenImageCellular(width: i32, height: i32, tileSize: i32): Image
fn GenImageCellular(width: i32, height: i32, tileSize: i32): Image {
	ret unsafe { extern.GenImageCellular(width, height, tileSize) }
}

// RLAPI Image GenImageText(int width, int height, const char *text);                                       // Generate image: grayscale image from text data
extern unsafe fn GenImageText(width: i32, height: i32, text: *extern.char): Image
fn GenImageText(width: i32, height: i32, text: str): Image {
	ret unsafe { extern.GenImageText(width, height, strToCharPtr(text)) }
}

//***********************************************************************************
// Image manipulation functions
// RLAPI Image ImageCopy(Image image);                                                                      // Create an image duplicate (useful for transformations)
extern unsafe fn ImageCopy(image: Image): Image
fn ImageCopy(image: Image): Image {
	ret unsafe { extern.ImageCopy(image) }
}

// I Image ImageFromImage(Image image, Rectangle rec);                                                  // Create an image from another image piece
extern unsafe fn ImageFromImage(image: Image, rec: Rectangle): Image
fn ImageFromImage(image: Image, rec: Rectangle): Image {
	ret unsafe { extern.ImageFromImage(image, rec) }
}

// RLAPI Image ImageFromChannel(Image image, int selectedChannel);                                          // Create an image from a selected channel of another image (GRAYSCALE)
extern unsafe fn ImageFromChannel(image: Image, selectedChannel: i32): Image
fn ImageFromChannel(image: Image, selectedChannel: i32): Image {
	ret unsafe { extern.ImageFromChannel(image, selectedChannel) }
}

// RLAPI Image ImageText(const char *text, int fontSize, Color color);                                      // Create an image from text (default font)
extern unsafe fn ImageText(text: *extern.char, fontSize: i32, color: Color): Image
fn ImageText(text: str, fontSize: i32, color: Color): Image {
	ret unsafe { extern.ImageText(strToCharPtr(text), fontSize, color) }
}

// RLAPI Image ImageTextEx(Font font, const char *text, float fontSize, float spacing, Color tint);         // Create an image from text (custom sprite font)
extern unsafe fn ImageTextEx(font: Font, text: *extern.char, fontSize: f32, spacing: f32, tint: Color): Image
fn ImageTextEx(font: Font, text: str, fontSize: f32, spacing: f32, tint: Color): Image {
	ret unsafe { extern.ImageTextEx(font, strToCharPtr(text), fontSize, spacing, tint) }
}

// RLAPI void ImageFormat(Image *image, int newFormat);                                                     // Convert image data to desired format
extern unsafe fn ImageFormat(image: *Image, newFormat: i32)
fn ImageFormat(image: *Image, newFormat: i32) {
	unsafe { extern.ImageFormat(image, newFormat) }
}

// RLAPI void ImageToPOT(Image *image, Color fill);                                                         // Convert image to POT (power-of-two)
extern unsafe fn ImageToPOT(image: *Image, fill: Color)
fn ImageToPOT(image: *Image, fill: Color) {
	unsafe { extern.ImageToPOT(image, fill) }
}

// RLAPI void ImageCrop(Image *image, Rectangle crop);                                                      // Crop an image to a defined rectangle
extern unsafe fn ImageCrop(image: *Image, crop: Rectangle)
fn ImageCrop(image: *Image, crop: Rectangle) {
	unsafe { extern.ImageCrop(image, crop) }
}

// RLAPI void ImageAlphaCrop(Image *image, float threshold);                                                // Crop image depending on alpha value
extern unsafe fn ImageAlphaCrop(image: *Image, threshold: f32)
fn ImageAlphaCrop(image: *Image, threshold: f32) {
	unsafe { extern.ImageAlphaCrop(image, threshold) }
}

// RLAPI void ImageAlphaClear(Image *image, Color color, float threshold);                                  // Clear alpha channel to desired color
extern unsafe fn ImageAlphaClear(image: *Image, color: Color, threshold: f32)
fn ImageAlphaClear(image: *Image, color: Color, threshold: f32) {
	unsafe { extern.ImageAlphaClear(image, color, threshold) }
}

// RLAPI void ImageAlphaMask(Image *image, Image alphaMask);                                                // Apply alpha mask to image
extern unsafe fn ImageAlphaMask(image: *Image, alphaMask: Image)
fn ImageAlphaMask(image: *Image, alphaMask: Image) {
	unsafe { extern.ImageAlphaMask(image, alphaMask) }
}

// RLAPI void ImageAlphaPremultiply(Image *image);                                                          // Premultiply alpha channel
extern unsafe fn ImageAlphaPremultiply(image: *Image)
fn ImageAlphaPremultiply(image: *Image) {
	unsafe { extern.ImageAlphaPremultiply(image) }
}

// RLAPI void ImageBlurGaussian(Image *image, int blurSize);                                                // Apply Gaussian blur using a box blur approximation
extern unsafe fn ImageBlurGaussian(image: *Image, blurSize: i32)
fn ImageBlurGaussian(image: *Image, blurSize: i32) {
	unsafe { extern.ImageBlurGaussian(image, blurSize) }
}

// RLAPI void ImageKernelConvolution(Image *image, const float *kernel, int kernelSize);                    // Apply custom square convolution kernel to image
extern unsafe fn ImageKernelConvolution(image: *Image, kernel: *f32, kernelSize: i32)
fn ImageKernelConvolution(image: *Image, kernel: *f32, kernelSize: i32) {
	unsafe { extern.ImageKernelConvolution(image, kernel, kernelSize) }
}

// RLAPI void ImageResize(Image *image, int newWidth, int newHeight);                                       // Resize image (Bicubic scaling algorithm)
extern unsafe fn ImageResize(image: *Image, newWidth: i32, newHeight: i32)
fn ImageResize(image: *Image, newWidth: i32, newHeight: i32) {
	unsafe { extern.ImageResize(image, newWidth, newHeight) }
}

// RLAPI void ImageResizeNN(Image *image, int newWidth,int newHeight);                                      // Resize image (Nearest-Neighbor scaling algorithm)
extern unsafe fn ImageResizeNN(image: *Image, newWidth: i32, newHeight: i32)
fn ImageResizeNN(image: *Image, newWidth: i32, newHeight: i32) {
	unsafe { extern.ImageResizeNN(image, newWidth, newHeight) }
}

// RLAPI void ImageResizeCanvas(Image *image, int newWidth, int newHeight, int offsetX, int offsetY, Color fill); // Resize canvas and fill with color
extern unsafe fn ImageResizeCanvas(image: *Image, newWidth: i32, newHeight: i32, offsetX: i32, offsetY: i32, fill: Color)
fn ImageResizeCanvas(image: *Image, newWidth: i32, newHeight: i32, offsetX: i32, offsetY: i32, fill: Color) {
	unsafe { extern.ImageResizeCanvas(image, newWidth, newHeight, offsetX, offsetY, fill) }
}

// RLAPI void ImageMipmaps(Image *image);                                                                   // Compute all mipmap levels for a provided image
extern unsafe fn ImageMipmaps(image: *Image)
fn ImageMipmaps(image: *Image) {
	unsafe { extern.ImageMipmaps(image) }
}

// RLAPI void ImageDither(Image *image, int rBpp, int gBpp, int bBpp, int aBpp);                            // Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
extern unsafe fn ImageDither(image: *Image, rBpp: i32, gBpp: i32, bBpp: i32, aBpp: i32)
fn ImageDither(image: *Image, rBpp: i32, gBpp: i32, bBpp: i32, aBpp: i32) {
	unsafe { extern.ImageDither(image, rBpp, gBpp, bBpp, aBpp) }
}

// RLAPI void ImageFlipVertical(Image *image);                                                              // Flip image vertically
extern unsafe fn ImageFlipVertical(image: *Image)
fn ImageFlipVertical(image: *Image) {
	unsafe { extern.ImageFlipVertical(image) }
}

// RLAPI void ImageFlipHorizontal(Image *image);                                                            // Flip image horizontally
extern unsafe fn ImageFlipHorizontal(image: *Image)
fn ImageFlipHorizontal(image: *Image) {
	unsafe { extern.ImageFlipHorizontal(image) }
}

// RLAPI void ImageRotate(Image *image, int degrees);                                                       // Rotate image by input angle in degrees (-359 to 359)
extern unsafe fn ImageRotate(image: *Image, degrees: i32)
fn ImageRotate(image: *Image, degrees: i32) {
	unsafe { extern.ImageRotate(image, degrees) }
}

// RLAPI void ImageRotateCW(Image *image);                                                                  // Rotate image clockwise 90deg
extern unsafe fn ImageRotateCW(image: *Image)
fn ImageRotateCW(image: *Image) {
	unsafe { extern.ImageRotateCW(image) }
}

// RLAPI void ImageRotateCCW(Image *image);                                                                 // Rotate image counter-clockwise 90deg
extern unsafe fn ImageRotateCCW(image: *Image)
fn ImageRotateCCW(image: *Image) {
	unsafe { extern.ImageRotateCCW(image) }
}

// RLAPI void ImageColorTint(Image *image, Color color);                                                    // Modify image color: tint
extern unsafe fn ImageColorTint(image: *Image, color: Color)
fn ImageColorTint(image: *Image, color: Color) {
	unsafe { extern.ImageColorTint(image, color) }
}

// RLAPI void ImageColorInvert(Image *image);                                                               // Modify image color: invert
extern unsafe fn ImageColorInvert(image: *Image)
fn ImageColorInvert(image: *Image) {
	unsafe { extern.ImageColorInvert(image) }
}

// RLAPI void ImageColorGrayscale(Image *image);                                                            // Modify image color: grayscale
extern unsafe fn ImageColorGrayscale(image: *Image)
fn ImageColorGrayscale(image: *Image) {
	unsafe { extern.ImageColorGrayscale(image) }
}

// RLAPI void ImageColorContrast(Image *image, float contrast);                                             // Modify image color: contrast (-100 to 100)
extern unsafe fn ImageColorContrast(image: *Image, contrast: f32)
fn ImageColorContrast(image: *Image, contrast: f32) {
	unsafe { extern.ImageColorContrast(image, contrast) }
}

// RLAPI void ImageColorBrightness(Image *image, int brightness);                                           // Modify image color: brightness (-255 to 255)
extern unsafe fn ImageColorBrightness(image: *Image, brightness: i32)
fn ImageColorBrightness(image: *Image, brightness: i32) {
	unsafe { extern.ImageColorBrightness(image, brightness) }
}

// RLAPI void ImageColorReplace(Image *image, Color color, Color replace);                                  // Modify image color: replace color
extern unsafe fn ImageColorReplace(image: *Image, color: Color, replace: Color)
fn ImageColorReplace(image: *Image, color: Color, replace: Color) {
	unsafe { extern.ImageColorReplace(image, color, replace) }
}

// RLAPI Color *LoadImageColors(Image image);                                                               // Load color data from image as a Color array (RGBA - 32bit)
extern unsafe fn LoadImageColors(image: Image): *Color
fn LoadImageColors(image: Image): *Color {
	ret unsafe { extern.LoadImageColors(image) }
}

// RLAPI Color *LoadImagePalette(Image image, int maxPaletteSize, int *colorCount);                         // Load colors palette from image as a Color array (RGBA - 32bit)
extern unsafe fn LoadImagePalette(image: Image, maxPaletteSize: i32, colorCount: *i32): *Color
fn LoadImagePalette(image: Image, maxPaletteSize: i32, colorCount: *i32): *Color {
	ret unsafe { extern.LoadImagePalette(image, maxPaletteSize, colorCount) }
}

// RLAPI void UnloadImageColors(Color *colors);                                                             // Unload color data loaded with LoadImageColors()
extern unsafe fn UnloadImageColors(colors: *Color)
fn UnloadImageColors(colors: *Color) {
	unsafe { extern.UnloadImageColors(colors) }
}

// RLAPI void UnloadImagePalette(Color *colors);                                                            // Unload colors palette loaded with LoadImagePalette()
extern unsafe fn UnloadImagePalette(colors: *Color)
fn UnloadImagePalette(colors: *Color) {
	unsafe { extern.UnloadImagePalette(colors) }
}

// RLAPI Rectangle GetImageAlphaBorder(Image image, float threshold);                                       // Get image alpha border rectangle
extern unsafe fn GetImageAlphaBorder(image: Image, threshold: f32): Rectangle
fn GetImageAlphaBorder(image: Image, threshold: f32): Rectangle {
	ret unsafe { extern.GetImageAlphaBorder(image, threshold) }
}

// RLAPI Color GetImageColor(Image image, int x, int y);                                                    // Get image pixel color at (x, y) position
extern unsafe fn GetImageColor(image: Image, x: i32, y: i32): Color
fn GetImageColor(image: Image, x: i32, y: i32): Color {
	ret unsafe { extern.GetImageColor(image, x, y) }
}

//**********************************************************************************
// Image drawing functions
// NOTE: Image software-rendering functions (CPU)
// RLAPI void ImageClearBackground(Image *dst, Color color);                                                // Clear image background with given color
extern unsafe fn ImageClearBackground(dst: *Image, color: Color)
fn ImageClearBackground(dst: *Image, color: Color) {
	unsafe { extern.ImageClearBackground(dst, color) }
}

// RLAPI void ImageDrawPixel(Image *dst, int posX, int posY, Color color);                                  // Draw pixel within an image
extern unsafe fn ImageDrawPixel(dst: *Image, posX: i32, posY: i32, color: Color)
fn ImageDrawPixel(dst: *Image, posX: i32, posY: i32, color: Color) {
	unsafe { extern.ImageDrawPixel(dst, posX, posY, color) }
}

// RLAPI void ImageDrawPixelV(Image *dst, Vector2 position, Color color);                                   // Draw pixel within an image (Vector version)
extern unsafe fn ImageDrawPixelV(dst: *Image, position: Vector2, color: Color)
fn ImageDrawPixelV(dst: *Image, position: Vector2, color: Color) {
	unsafe { extern.ImageDrawPixelV(dst, position, color) }
}

// RLAPI void ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color); // Draw line within an image
extern unsafe fn ImageDrawLine(dst: *Image, startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color)
fn ImageDrawLine(dst: *Image, startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color) {
	unsafe { extern.ImageDrawLine(dst, startPosX, startPosY, endPosX, endPosY, color) }
}

// RLAPI void ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color);                          // Draw line within an image (Vector version)
extern unsafe fn ImageDrawLineV(dst: *Image, start: Vector2, end: Vector2, color: Color)
fn ImageDrawLineV(dst: *Image, start: Vector2, end: Vector2, color: Color) {
	unsafe { extern.ImageDrawLineV(dst, start, end, color) }
}

// RLAPI void ImageDrawLineEx(Image *dst, Vector2 start, Vector2 end, int thick, Color color);              // Draw a line defining thickness within an image
extern unsafe fn ImageDrawLineEx(dst: *Image, start: Vector2, end: Vector2, thick: i32, color: Color)
fn ImageDrawLineEx(dst: *Image, start: Vector2, end: Vector2, thick: i32, color: Color) {
	unsafe { extern.ImageDrawLineEx(dst, start, end, thick, color) }
}

// RLAPI void ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color);               // Draw a filled circle within an image
extern unsafe fn ImageDrawCircle(dst: *Image, centerX: i32, centerY: i32, radius: i32, color: Color)
fn ImageDrawCircle(dst: *Image, centerX: i32, centerY: i32, radius: i32, color: Color) {
	unsafe { extern.ImageDrawCircle(dst, centerX, centerY, radius, color) }
}

// RLAPI void ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color);                        // Draw a filled circle within an image (Vector version)
extern unsafe fn ImageDrawCircleV(dst: *Image, center: Vector2, radius: i32, color: Color)
fn ImageDrawCircleV(dst: *Image, center: Vector2, radius: i32, color: Color) {
	unsafe { extern.ImageDrawCircleV(dst, center, radius, color) }
}

// RLAPI void ImageDrawCircleLines(Image *dst, int centerX, int centerY, int radius, Color color);          // Draw circle outline within an image
extern unsafe fn ImageDrawCircleLines(dst: *Image, centerX: i32, centerY: i32, radius: i32, color: Color)
fn ImageDrawCircleLines(dst: *Image, centerX: i32, centerY: i32, radius: i32, color: Color) {
	unsafe { extern.ImageDrawCircleLines(dst, centerX, centerY, radius, color) }
}

// RLAPI void ImageDrawCircleLinesV(Image *dst, Vector2 center, int radius, Color color);                   // Draw circle outline within an image (Vector version)
extern unsafe fn ImageDrawCircleLinesV(dst: *Image, center: Vector2, radius: i32, color: Color)
fn ImageDrawCircleLinesV(dst: *Image, center: Vector2, radius: i32, color: Color) {
	unsafe { extern.ImageDrawCircleLinesV(dst, center, radius, color) }
}

//************
// RLAPI void ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color);       // Draw rectangle within an image
extern unsafe fn ImageDrawRectangle(dst: *Image, posX: i32, posY: i32, width: i32, height: i32, color: Color)
fn ImageDrawRectangle(dst: *Image, posX: i32, posY: i32, width: i32, height: i32, color: Color) {
	unsafe { extern.ImageDrawRectangle(dst, posX, posY, width, height, color) }
}

// RLAPI void ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color);                 // Draw rectangle within an image (Vector version)
extern unsafe fn ImageDrawRectangleV(dst: *Image, position: Vector2, size: Vector2, color: Color)
fn ImageDrawRectangleV(dst: *Image, position: Vector2, size: Vector2, color: Color) {
	unsafe { extern.ImageDrawRectangleV(dst, position, size, color) }
}

// RLAPI void ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color);                                // Draw rectangle within an image
extern unsafe fn ImageDrawRectangleRec(dst: *Image, rec: Rectangle, color: Color)
fn ImageDrawRectangleRec(dst: *Image, rec: Rectangle, color: Color) {
	unsafe { extern.ImageDrawRectangleRec(dst, rec, color) }
}

// RLAPI void ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color);                   // Draw rectangle lines within an image
extern unsafe fn ImageDrawRectangleLines(dst: *Image, rec: Rectangle, thick: i32, color: Color)
fn ImageDrawRectangleLines(dst: *Image, rec: Rectangle, thick: i32, color: Color) {
	unsafe { extern.ImageDrawRectangleLines(dst, rec, thick, color) }
}

// RLAPI void ImageDrawTriangle(Image *dst, Vector2 v1, Vector2 v2, Vector2 v3, Color color);               // Draw triangle within an image
extern unsafe fn ImageDrawTriangle(dst: *Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color)
fn ImageDrawTriangle(dst: *Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color) {
	unsafe { extern.ImageDrawTriangle(dst, v1, v2, v3, color) }
}

// RLAPI void ImageDrawTriangleEx(Image *dst, Vector2 v1, Vector2 v2, Vector2 v3, Color c1, Color c2, Color c3); // Draw triangle with interpolated colors within an image
extern unsafe fn ImageDrawTriangleEx(dst: *Image, v1: Vector2, v2: Vector2, v3: Vector2, c1: Color, c2: Color, c3: Color)
fn ImageDrawTriangleEx(dst: *Image, v1: Vector2, v2: Vector2, v3: Vector2, c1: Color, c2: Color, c3: Color) {
	unsafe { extern.ImageDrawTriangleEx(dst, v1, v2, v3, c1, c2, c3) }
}

// RLAPI void ImageDrawTriangleLines(Image *dst, Vector2 v1, Vector2 v2, Vector2 v3, Color color);          // Draw triangle outline within an image
extern unsafe fn ImageDrawTriangleLines(dst: *Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color)
fn ImageDrawTriangleLines(dst: *Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color) {
	unsafe { extern.ImageDrawTriangleLines(dst, v1, v2, v3, color) }
}

// RLAPI void ImageDrawTriangleFan(Image *dst, Vector2 *points, int pointCount, Color color);               // Draw a triangle fan defined by points within an image (first vertex is the center)
extern unsafe fn ImageDrawTriangleFan(dst: *Image, points: *Vector2, pointCount: i32, color: Color)
fn ImageDrawTriangleFan(dst: *Image, points: []Vector2, pointCount: i32, color: Color) {
	unsafe { extern.ImageDrawTriangleFan(dst, &points[0], pointCount, color) }
}

// RLAPI void ImageDrawTriangleStrip(Image *dst, Vector2 *points, int pointCount, Color color);             // Draw a triangle strip defined by points within an image
extern unsafe fn ImageDrawTriangleStrip(dst: *Image, points: *Vector2, pointCount: i32, color: Color)
fn ImageDrawTriangleStrip(dst: *Image, points: []Vector2, pointCount: i32, color: Color) {
	unsafe { extern.ImageDrawTriangleStrip(dst, &points[0], pointCount, color) }
}

// RLAPI void ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint);             // Draw a source image within a destination image (tint applied to source)
extern unsafe fn ImageDraw(dst: *Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color)
fn ImageDraw(dst: *Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color) {
	unsafe { extern.ImageDraw(dst, src, srcRec, dstRec, tint) }
}

// RLAPI void ImageDrawText(Image *dst, const char *text, int posX, int posY, int fontSize, Color color);   // Draw text (using default font) within an image (destination)
extern unsafe fn ImageDrawText(dst: *Image, text: *extern.char, posX: i32, posY: i32, fontSize: i32, color: Color)
fn ImageDrawText(dst: *Image, text: str, posX: i32, posY: i32, fontSize: i32, color: Color) {
	unsafe { extern.ImageDrawText(dst, strToCharPtr(text), posX, posY, fontSize, color) }
}

// RLAPI void ImageDrawTextEx(Image *dst, Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint); // Draw text (custom sprite font) within an image (destination)
extern unsafe fn ImageDrawTextEx(dst: *Image, font: Font, text: *extern.char, position: Vector2, fontSize: f32, spacing: f32, tint: Color)
fn ImageDrawTextEx(dst: *Image, font: Font, text: str, position: Vector2, fontSize: f32, spacing: f32, tint: Color) {
	unsafe { extern.ImageDrawTextEx(dst, font, strToCharPtr(text), position, fontSize, spacing, tint) }
}

// Texture loading functions
// NOTE: These functions require GPU access
// RLAPI Texture2D LoadTexture(const char *fileName);                                                       // Load texture from file into GPU memory (VRAM)
extern unsafe fn LoadTexture(fileName: *extern.char): Texture2D
fn LoadTexture(fileName: str): Texture2D {
	ret unsafe { extern.LoadTexture(strToCharPtr(fileName)) }
}

// RLAPI Texture2D LoadTextureFromImage(Image image);                                                       // Load texture from image data
extern unsafe fn LoadTextureFromImage(image: Image): Texture2D
fn LoadTextureFromImage(image: Image): Texture2D {
	ret unsafe { extern.LoadTextureFromImage(image) }
}

// RLAPI TextureCubemap LoadTextureCubemap(Image image, int layout);                                        // Load cubemap from image, multiple image cubemap layouts supported
extern unsafe fn LoadTextureCubemap(image: Image, layout: i32): TextureCubemap
fn LoadTextureCubemap(image: Image, layout: i32): TextureCubemap {
	ret unsafe { extern.LoadTextureCubemap(image, layout) }
}

// RLAPI RenderTexture2D LoadRenderTexture(int width, int height);                                          // Load texture for rendering (framebuffer)
extern unsafe fn LoadRenderTexture(width: i32, height: i32): RenderTexture2D
fn LoadRenderTexture(width: i32, height: i32): RenderTexture2D {
	ret unsafe { extern.LoadRenderTexture(width, height) }
}

// RLAPI bool IsTextureValid(Texture2D texture);                                                            // Check if a texture is valid (loaded in GPU)
extern unsafe fn IsTextureValid(texture: Texture2D): bool
fn IsTextureValid(texture: Texture2D): bool {
	ret unsafe { extern.IsTextureValid(texture) }
}

// RLAPI void UnloadTexture(Texture2D texture);                                                             // Unload texture from GPU memory (VRAM)
extern unsafe fn UnloadTexture(texture: Texture2D)
fn UnloadTexture(texture: Texture2D) {
	unsafe { extern.UnloadTexture(texture) }
}

// RLAPI bool IsRenderTextureValid(RenderTexture2D target);                                                 // Check if a render texture is valid (loaded in GPU)
extern unsafe fn IsRenderTextureValid(target: RenderTexture2D): bool
fn IsRenderTextureValid(target: RenderTexture2D): bool {
	ret unsafe { extern.IsRenderTextureValid(target) }
}

// RLAPI void UnloadRenderTexture(RenderTexture2D target);                                                  // Unload render texture from GPU memory (VRAM)
extern unsafe fn UnloadRenderTexture(target: RenderTexture2D)
fn UnloadRenderTexture(target: RenderTexture2D) {
	unsafe { extern.UnloadRenderTexture(target) }
}

// RLAPI void UpdateTexture(Texture2D texture, const void *pixels);                                         // Update GPU texture with new data
extern unsafe fn UpdateTexture(texture: Texture2D, pixels: extern.Void)
fn UpdateTexture(texture: Texture2D, pixels: extern.Void) {
	unsafe { extern.UpdateTexture(texture, pixels) }
}

// RLAPI void UpdateTextureRec(Texture2D texture, Rectangle rec, const void *pixels);                       // Update GPU texture rectangle with new data
extern unsafe fn UpdateTextureRec(texture: Texture2D, rec: Rectangle, pixels: extern.Void)
fn UpdateTextureRec(texture: Texture2D, rec: Rectangle, pixels: extern.Void) {
	unsafe { extern.UpdateTextureRec(texture, rec, pixels) }
}

//********************************************************
// Texture drawing functions
// RLAPI void DrawTexture(Texture2D texture, int posX, int posY, Color tint);                               // Draw a Texture2D
extern unsafe fn DrawTexture(texture: Texture2D, posX: int, posY: int, tint: Color)
fn DrawTexture(texture: Texture2D, posX: int, posY: int, tint: Color) {
	unsafe { extern.DrawTexture(texture, posX, posY, tint) }
}

// RLAPI void DrawTextureV(Texture2D texture, Vector2 position, Color tint);                                // Draw a Texture2D with position defined as Vector2
extern unsafe fn DrawTextureV(texture: Texture2D, position: Vector2, tint: Color)
fn DrawTextureV(texture: Texture2D, position: Vector2, tint: Color) {
	unsafe { extern.DrawTextureV(texture, position, tint) }
}

// RLAPI void DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint);  // Draw a Texture2D with extended parameters
extern unsafe fn DrawTextureEx(texture: Texture2D, position: Vector2, rotation: f32, scale: f32, tint: Color)
fn DrawTextureEx(texture: Texture2D, position: Vector2, rotation: f32, scale: f32, tint: Color) {
	unsafe { extern.DrawTextureEx(texture, position, rotation, scale, tint) }
}

// RLAPI void DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint);            // Draw a part of a texture defined by a rectangle
extern unsafe fn DrawTextureRec(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color)
fn DrawTextureRec(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color) {
	unsafe { extern.DrawTextureRec(texture, source, position, tint) }
}

// RLAPI void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint); // Draw a part of a texture defined by a rectangle with 'pro' parameters
extern unsafe fn DrawTexturePro(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color)
fn DrawTexturePro(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color) {
	unsafe { extern.DrawTexturePro(texture, source, dest, origin, rotation, tint) }
}

// RLAPI void DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint); // Draws a texture (or part of it) that stretches or shrinks nicely
extern unsafe fn DrawTextureNPatch(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color)
fn DrawTextureNPatch(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color) {
	unsafe { extern.DrawTextureNPatch(texture, nPatchInfo, dest, origin, rotation, tint) }
}

//******************************************************************************************
// Font loading/unloading functions
// RLAPI Font GetFontDefault(void);
extern unsafe fn GetFontDefault(): Font
fn GetFontDefault(): Font {
	ret unsafe { extern.GetFontDefault() }
}
// RLAPI Font LoadFont(const char *fileName);
extern unsafe fn LoadFont(filename: *extern.char): Font
fn LoadFont(filename: *extern.char): Font {
	ret unsafe { extern.LoadFont(filename) }
}
// RLAPI Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount);
extern unsafe fn LoadFontEx(filename: *extern.char, fontSize: int, codepoints: *i32, codepointCount: int): Font
fn LoadFontEx(filename: *extern.char, fontSize: int, codepoints: *i32, codepointCount: int): Font {
	ret unsafe { extern.LoadFontEx(filename, fontSize, codepoints, codepointCount) }
}
// RLAPI void UnloadFont(Font font);
extern unsafe fn UnloadFont(font: Font)
fn UnloadFont(font: Font) {
	unsafe { extern.UnloadFont(font) }
}

// Model management functions
// RLAPI Model LoadModel(const char *fileName);                                                // Load model from files (meshes and materials)
extern unsafe fn LoadModel(fileName: *extern.char): Model
fn LoadModel(fileName: str): Model {
	ret unsafe { extern.LoadModel(strToCharPtr(fileName)) }
}

// RLAPI Model LoadModelFromMesh(Mesh mesh);                                                   // Load model from generated mesh (default material)
extern unsafe fn LoadModelFromMesh(mesh: Mesh): Model
fn LoadModelFromMesh(mesh: Mesh): Model {
	ret unsafe { extern.LoadModelFromMesh(mesh) }
}

// RLAPI bool IsModelValid(Model model);                                                       // Check if a model is valid (loaded in GPU, VAO/VBOs)
extern unsafe fn IsModelValid(model: Model): bool
fn IsModelValid(model: Model): bool {
	ret unsafe { extern.IsModelValid(model) }
}

// RLAPI void UnloadModel(Model model);                                                        // Unload model (including meshes) from memory (RAM and/or VRAM)
extern unsafe fn UnloadModel(model: Model)
fn UnloadModel(model: Model) {
	unsafe { extern.UnloadModel(model) }
}

// RLAPI BoundingBox GetModelBoundingBox(Model model);                                         // Compute model bounding box limits (considers all meshes)
extern unsafe fn GetModelBoundingBox(model: Model): BoundingBox
fn GetModelBoundingBox(model: Model): BoundingBox {
	ret unsafe { extern.GetModelBoundingBox(model) }
}

//**********************************************************

// Model drawing functions
// RLAPI void DrawModel(Model model, Vector3 position, float scale, Color tint);               // Draw a model (with texture if set)
extern unsafe fn DrawModel(model: Model, position: Vector3, scale: f32, tint: Color)
fn DrawModel(model: Model, position: Vector3, scale: f32, tint: Color) {
	unsafe { extern.DrawModel(model, position, scale, tint) }
}

// RLAPI void DrawModelEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint); // Draw a model with extended parameters
extern unsafe fn DrawModelEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color)
fn DrawModelEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color) {
	unsafe { extern.DrawModelEx(model, position, rotationAxis, rotationAngle, scale, tint) }
}

// RLAPI void DrawModelWires(Model model, Vector3 position, float scale, Color tint);          // Draw a model wires (with texture if set)
extern unsafe fn DrawModelWires(model: Model, position: Vector3, scale: f32, tint: Color)
fn DrawModelWires(model: Model, position: Vector3, scale: f32, tint: Color) {
	unsafe { extern.DrawModelWires(model, position, scale, tint) }
}

// RLAPI void DrawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint); // Draw a model wires (with texture if set) with extended parameters
extern unsafe fn DrawModelWiresEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color)
fn DrawModelWiresEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color) {
	unsafe { extern.DrawModelWiresEx(model, position, rotationAxis, rotationAngle, scale, tint) }
}

// RLAPI void DrawModelPoints(Model model, Vector3 position, float scale, Color tint); // Draw a model as points
extern unsafe fn DrawModelPoints(model: Model, position: Vector3, scale: f32, tint: Color)
fn DrawModelPoints(model: Model, position: Vector3, scale: f32, tint: Color) {
	unsafe { extern.DrawModelPoints(model, position, scale, tint) }
}

// RLAPI void DrawModelPointsEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint); // Draw a model as points with extended parameters
extern unsafe fn DrawModelPointsEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color)
fn DrawModelPointsEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color) {
	unsafe { extern.DrawModelPointsEx(model, position, rotationAxis, rotationAngle, scale, tint) }
}

// RLAPI void DrawBoundingBox(BoundingBox box, Color color);                                   // Draw bounding box (wires)
extern unsafe fn DrawBoundingBox(box: BoundingBox, color: Color)
fn DrawBoundingBox(box: BoundingBox, color: Color) {
	unsafe { extern.DrawBoundingBox(box, color) }
}

// RLAPI void DrawBillboard(Camera camera, Texture2D texture, Vector3 position, float scale, Color tint);   // Draw a billboard texture
extern unsafe fn DrawBillboard(camera: Camera, texture: Texture2D, position: Vector3, scale: f32, tint: Color)
fn DrawBillboard(camera: Camera, texture: Texture2D, position: Vector3, scale: f32, tint: Color) {
	unsafe { extern.DrawBillboard(camera, texture, position, scale, tint) }
}

// RLAPI void DrawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint); // Draw a billboard texture defined by source
extern unsafe fn DrawBillboardRec(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color)
fn DrawBillboardRec(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color) {
	unsafe { extern.DrawBillboardRec(camera, texture, source, position, size, tint) }
}

// RLAPI void DrawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint); // Draw a billboard texture defined by source and rotation
extern unsafe fn DrawBillboardPro(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: f32, tint: Color)
fn DrawBillboardPro(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: f32, tint: Color) {
	unsafe { extern.DrawBillboardPro(camera, texture, source, position, up, size, origin, rotation, tint) }
}

//**********************************************************
// Audio Loading and Playing Functions (Module: audio)
// TODO:

